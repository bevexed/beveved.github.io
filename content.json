{"meta":{"title":"bev","subtitle":"Daily","description":"前端日常学习","author":"bev","url":"http://blog.bevexed.top"},"pages":[{"title":"about","date":"2019-01-22T08:40:05.000Z","updated":"2019-01-22T08:40:05.844Z","comments":true,"path":"about/index.html","permalink":"http://blog.bevexed.top/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-01-22T08:40:41.000Z","updated":"2019-01-22T08:40:41.491Z","comments":true,"path":"archives/index.html","permalink":"http://blog.bevexed.top/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-01-21T09:21:34.000Z","updated":"2019-01-22T10:43:17.071Z","comments":true,"path":"categories/index.html","permalink":"http://blog.bevexed.top/categories/index.html","excerpt":"","text":""},{"title":"home","date":"2019-01-22T10:45:49.000Z","updated":"2019-01-22T10:46:13.548Z","comments":true,"path":"home/index.html","permalink":"http://blog.bevexed.top/home/index.html","excerpt":"","text":""},{"title":"schedule","date":"2019-01-22T08:41:04.000Z","updated":"2019-01-29T10:08:24.225Z","comments":true,"path":"schedule/index.html","permalink":"http://blog.bevexed.top/schedule/index.html","excerpt":"","text":""},{"title":"sitemap","date":"2019-01-22T08:42:09.000Z","updated":"2019-01-22T08:42:09.109Z","comments":true,"path":"sitemap/index.html","permalink":"http://blog.bevexed.top/sitemap/index.html","excerpt":"","text":""},{"title":"sitemap","date":"2019-02-11T06:25:21.000Z","updated":"2019-02-11T06:25:21.938Z","comments":true,"path":"sitemap/index-1.html","permalink":"http://blog.bevexed.top/sitemap/index-1.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-22T08:40:15.000Z","updated":"2019-01-22T08:52:30.489Z","comments":true,"path":"tags/index.html","permalink":"http://blog.bevexed.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"树/exercise","date":"2019-06-13T05:44:01.337Z","updated":"2019-06-13T05:44:01.352Z","comments":true,"path":"2019/06/13/树/exercise/","link":"","permalink":"http://blog.bevexed.top/2019/06/13/树/exercise/","excerpt":"","text":"Binary Tree .root { display: flex; border: 1px solid #000; width: 600px; margin: 0 auto; height: 150px; align-items: center; justify-content: center; } .root div { display: flex; height: 70%; width: 44%; margin: 0 3%; border: 1px solid #000; justify-content: center; align-items: center; background: #fff; } 1 2 4 5 3 6 7 /** * 深度优先遍历的递归写法 * 原理：递归的回溯性 */ class TravelTree { constructor() { this.nodeList = []; } preOrder = node => { if (node) { this.nodeList.push(node.firstChild.textContent.trim()); this.preOrder(node.firstElementChild); this.preOrder(node.lastElementChild); } }; inOrder = node => { if (node) { this.inOrder(node.firstElementChild); this.nodeList.push(node.firstChild.textContent.trim()); this.inOrder(node.lastElementChild); } }; postOrder = node => { if (node) { this.postOrder(node.firstElementChild); this.postOrder(node.lastElementChild); this.nodeList.push(node.firstChild.textContent.trim()); } }; reset() { this.nodeList = []; } } let node = document.querySelector('.root'); let tree = new TravelTree(); console.log('TravelTree'); tree.reset(); tree.preOrder(node); console.log(tree.nodeList); tree.reset(); tree.inOrder(node); console.log(tree.nodeList); tree.reset(); tree.postOrder(node); console.log(tree.nodeList); // 深度优先遍历的非递归写法 class StackTree { constructor() { this.nodeList = []; this.stack = [] } preOrder(node) { let treeNode = node; while (treeNode || this.stack.length) { // 进栈 将所有左节点压栈 while (treeNode) { this.stack.push(treeNode); this.nodeList.push(treeNode.firstChild.textContent.trim()); treeNode = treeNode.firstElementChild; } // 出栈 if (this.stack.length) { treeNode = this.stack.pop(); treeNode = treeNode.lastElementChild; } } } inOrder(node) { let treeNode = node; while (treeNode || this.stack.length) { while (treeNode) { this.stack.push(treeNode); treeNode = treeNode.firstElementChild; } if (this.stack.length) { treeNode = this.stack.pop(); this.nodeList.push(treeNode.firstChild.textContent.trim()); treeNode = treeNode.lastElementChild; } } } /* * 将根节点压入第一个栈 * 从第一个栈中弹出一个元素，压入第二个栈 * 然后分别将该节点的左右孩子压入第一个栈 * 重复步骤2和步骤3直到第一个栈为空 * 执行结束，第二个栈中就保存了所有节点的后序遍历输出结果。依次将元素从第二个栈中弹出即可。 */ postOrder(node) { let treeNode = node; this.stack.push(treeNode); while (this.stack.length) { treeNode = this.stack.pop(); this.nodeList.unshift(treeNode.firstChild.textContent.trim()); if (treeNode.firstElementChild) { this.stack.push(treeNode.firstElementChild) } if (treeNode.lastElementChild) { this.stack.push(treeNode.lastElementChild) } } } reset() { this.stack = []; this.nodeList = []; } } let stackTree = new StackTree(); console.log('stackTree'); stackTree.preOrder(node); console.log(stackTree.nodeList); stackTree.reset(); stackTree.inOrder(node); console.log(stackTree.nodeList); stackTree.reset(); stackTree.postOrder(node); console.log(stackTree.nodeList); // 广度度优先遍历非递归 class WidthTravelTree { constructor() { this.nodeList = []; this.stack = [] } // 队列 widthTravel(node) { if (node) { this.stack.push(node); this.nodeList.push(node.firstChild.textContent.trim()); while (this.stack.length) { let item = this.stack.shift(); if (item.firstElementChild) { this.nodeList.push(item.firstElementChild.firstChild.textContent.trim()); this.stack.push(item.firstElementChild); } if (item.lastElementChild) { this.nodeList.push(item.lastElementChild.firstChild.textContent.trim()); this.stack.push(item.lastElementChild) } } } } } console.log('WidthTravelTree'); let widthTravelTree = new WidthTravelTree(); widthTravelTree.widthTravel(node); console.log(widthTravelTree.nodeList);","categories":[],"tags":[]},{"title":"","slug":"树/demo","date":"2019-06-10T09:21:29.548Z","updated":"2019-06-11T09:18:56.233Z","comments":true,"path":"2019/06/10/树/demo/","link":"","permalink":"http://blog.bevexed.top/2019/06/10/树/demo/","excerpt":"","text":"Document * { margin: 0; padding: 0; } .wrap { display: flex; border: 1px solid #000; width: 600px; margin: 0 auto; height: 150px; align-items: center; justify-content: center; } .wrap div { display: flex; height: 70%; width: 44%; margin: 0 3%; border: 1px solid #000; justify-content: center; align-items: center; background: #fff; } .btn-wrap { text-align: center; padding-top: 20px; } .btn-wrap button { display: inline-block; padding: 4px 10px; } 前序 中序 后序 let wrap = document.querySelector(\".wrap\"); let btn_wrap = document.querySelector(\".btn-wrap\"); let btn1 = btn_wrap.querySelectorAll(\"button\")[0]; let btn2 = btn_wrap.querySelectorAll(\"button\")[1]; let btn3 = btn_wrap.querySelectorAll(\"button\")[2]; let arr = []; let last; let toggle = false; //给按钮绑定事件 btn1.onclick = function () { if (!toggle) { toggle = true; reset(); preOrder(wrap); showWay(); } }; btn2.onclick = function () { if (!toggle) { toggle = true; reset(); inOrder(wrap); showWay(); } }; btn3.onclick = function () { if (!toggle) { toggle = true; reset(); postOrder(wrap); showWay(); } }; //二叉树的遍历的三种方式 //(1)前序遍历（DLR) function preOrder(node) { if (node) { arr.push(node); preOrder(node.firstElementChild); preOrder(node.lastElementChild); } } //(2)中序遍历（LDR） function inOrder(node) { if (node) { inOrder(node.firstElementChild); arr.push(node); inOrder(node.lastElementChild); } } //(3)后序遍历（LRD） function postOrder(node) { if (node) { postOrder(node.firstElementChild); postOrder(node.lastElementChild); arr.push(node); } } //显示遍历的过程 function showWay() { for (let i = 0; i < arr.length; i++) { setTimeout(function (i) { return function () { if (i === arr.length - 1) { toggle = false; } if (last) { last.style.background = \"white\"; } arr[i].style.background = \"red\"; last = arr[i]; } }(i), i * 1000) } } //初始化 function reset() { arr = []; if (last) { last.style.background = \"white\"; } }","categories":[],"tags":[]},{"title":"树","slug":"树","date":"2019-05-15T09:11:36.000Z","updated":"2019-06-13T05:43:37.110Z","comments":true,"path":"2019/05/15/树/","link":"","permalink":"http://blog.bevexed.top/2019/05/15/树/","excerpt":"","text":"树 tree 树（tree）是n（n&gt;=0）个节点的有限集合。 当 n=0 时，称为空树 在任意一个非空树中有如下特点 有且仅有一个特定的称为根（root）的节点 当 n&gt;1 时，其余节点可分为m（m&gt;0）个互不相交的有限集，每一个集合本身又是一个树，称为根的子树 节点的末端，叫做 叶子节点（leaf） 二叉树 binary tree 树的一种特殊结构 每个节点最多有两个子节点 二叉树节点的两个孩子节点，一个被称为左孩子（left child），一个被称为右孩子（right child） 这两个孩子顺序固定，不可颠倒 存储结构 链式存储结构 数组 满二叉树 一个二叉树的所有非叶子节点都存在左右孩子 所有叶子节点都在同一层级上 完全二叉树 对一个有 n 个节点的二叉树，按层级顺序编号，则所有节点的编号为从 1 到 n 。如果这个树所有节点和同样深度的满二叉树的编号为从 1 到 n 的节点位置相同，则这个二叉树为完全二叉树 二叉查找树 也叫二叉排序树 如果左子树不为空，则左子树上所有节点的值均小于根节点的值 如果右子树不为空，则右子树上所有节点的值均大于根节点的值 左右子树也是二叉树查找 对于一个节点分布相对均衡的二叉查找树来说，如果节点总数是 n，那么搜索节点的时间复杂度为 O(logn),和数的深度一样 二叉树的自平衡 二叉树与存储结构链式存储结构二叉树的每一个节点由三部分组成 存储数据的 data 变量 指向左孩子的 left 指针 指向右孩子的 right 指针 数组存储结构 按照层级顺序把二叉树的节点放到数组的对应位置上 如果某一节点的左孩子或右孩子空缺，则数组的相应位置也空出来 假设一个父节点的下标为 parent，那么它的左孩子的下标为 2 * parent + 1，它的右孩子的下标为 2 * parent + 2 假设一个左孩子的下标为 leftChilde ，那么他的父节点的下标为 (leftChild - 1) / 2 应用二叉查找树（binary search tree）二叉查找树在二叉树的基础上增加了以下条件 如果左子树不为空，则左子树上所有节点的值均小于根节点的值 如果右子树不为空，则右子树上所有节点的值均大于根节点的值 左右子叶也是二叉树查找 时间复杂度 O(logn), n 为树的深度 维持相对顺序 二叉查找树的左子树小于父节点，右子树大于父节点，保证了二叉树的有序性 二叉树遍历将 非线性的数据结构 转换成 线性的序列 深度优先遍历 (demo)偏向于深度，一头扎到底的访问方式 前序遍历（DLR) 过程 先访问 根节点 遍历 左子树 遍历 右子树 结果 : ABDECF 中序遍历（LDR） 过程左 根 右 结果 : DBEACF 后序遍历（LRD） 过程左 右 根 结果 ： DEBFCA demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Binary Tree&lt;/title&gt; &lt;style&gt; .root &#123; display: flex; border: 1px solid #000; width: 600px; margin: 0 auto; height: 150px; align-items: center; justify-content: center; &#125; .root div &#123; display: flex; height: 70%; width: 44%; margin: 0 3%; border: 1px solid #000; justify-content: center; align-items: center; background: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"root\"&gt; 1 &lt;div&gt;2 &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;/div&gt; &lt;div&gt;3 &lt;div&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; /** * 深度优先遍历的递归写法 * 原理：递归的回溯性 */ class TravelTree &#123; constructor() &#123; this.nodeList = []; &#125; preOrder = node =&gt; &#123; if (node) &#123; this.nodeList.push(node.firstChild.textContent.trim()); this.preOrder(node.firstElementChild); this.preOrder(node.lastElementChild); &#125; &#125;; inOrder = node =&gt; &#123; if (node) &#123; this.inOrder(node.firstElementChild); this.nodeList.push(node.firstChild.textContent.trim()); this.inOrder(node.lastElementChild); &#125; &#125;; postOrder = node =&gt; &#123; if (node) &#123; this.postOrder(node.firstElementChild); this.postOrder(node.lastElementChild); this.nodeList.push(node.firstChild.textContent.trim()); &#125; &#125;; reset() &#123; this.nodeList = []; &#125; &#125; let node = document.querySelector('.root'); let tree = new TravelTree(); console.log('TravelTree'); tree.reset(); tree.preOrder(node); console.log(tree.nodeList); tree.reset(); tree.inOrder(node); console.log(tree.nodeList); tree.reset(); tree.postOrder(node); console.log(tree.nodeList); // 深度优先遍历的非递归写法 class StackTree &#123; constructor() &#123; this.nodeList = []; this.stack = [] &#125; preOrder(node) &#123; let treeNode = node; while (treeNode || this.stack.length) &#123; // 进栈 将所有左节点压栈 while (treeNode) &#123; this.stack.push(treeNode); this.nodeList.push(treeNode.firstChild.textContent.trim()); treeNode = treeNode.firstElementChild; &#125; // 出栈 if (this.stack.length) &#123; treeNode = this.stack.pop(); treeNode = treeNode.lastElementChild; &#125; &#125; &#125; inOrder(node) &#123; let treeNode = node; while (treeNode || this.stack.length) &#123; while (treeNode) &#123; this.stack.push(treeNode); treeNode = treeNode.firstElementChild; &#125; if (this.stack.length) &#123; treeNode = this.stack.pop(); this.nodeList.push(treeNode.firstChild.textContent.trim()); treeNode = treeNode.lastElementChild; &#125; &#125; &#125; /* * 将根节点压入第一个栈 * 从第一个栈中弹出一个元素，压入第二个栈 * 然后分别将该节点的左右孩子压入第一个栈 * 重复步骤2和步骤3直到第一个栈为空 * 执行结束，第二个栈中就保存了所有节点的后序遍历输出结果。依次将元素从第二个栈中弹出即可。 */ postOrder(node) &#123; let treeNode = node; this.stack.push(treeNode); while (this.stack.length) &#123; treeNode = this.stack.pop(); this.nodeList.unshift(treeNode.firstChild.textContent.trim()); if (treeNode.firstElementChild) &#123; this.stack.push(treeNode.firstElementChild) &#125; if (treeNode.lastElementChild) &#123; this.stack.push(treeNode.lastElementChild) &#125; &#125; &#125; reset() &#123; this.stack = []; this.nodeList = []; &#125; &#125; let stackTree = new StackTree(); console.log('stackTree'); stackTree.preOrder(node); console.log(stackTree.nodeList); stackTree.reset(); stackTree.inOrder(node); console.log(stackTree.nodeList); stackTree.reset(); stackTree.postOrder(node); console.log(stackTree.nodeList); // 广度度优先遍历非递归 class WidthTravelTree &#123; constructor() &#123; this.nodeList = []; this.stack = [] &#125; // 队列 widthTravel(node) &#123; if (node) &#123; this.stack.push(node); this.nodeList.push(node.firstChild.textContent.trim()); while (this.stack.length) &#123; let item = this.stack.shift(); if (item.firstElementChild) &#123; this.nodeList.push(item.firstElementChild.firstChild.textContent.trim()); this.stack.push(item.firstElementChild); &#125; if (item.lastElementChild) &#123; this.nodeList.push(item.lastElementChild.firstChild.textContent.trim()); this.stack.push(item.lastElementChild) &#125; &#125; &#125; &#125; &#125; console.log('WidthTravelTree'); let widthTravelTree = new WidthTravelTree(); widthTravelTree.widthTravel(node); console.log(widthTravelTree.nodeList);&lt;/script&gt;&lt;/html&gt; 广度优先遍历 层序遍历 资料参考 图片来源","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.bevexed.top/categories/算法/"}],"tags":[]},{"title":"数据结构基础","slug":"数据结构基础","date":"2019-05-14T09:14:47.000Z","updated":"2019-05-15T08:55:59.530Z","comments":true,"path":"2019/05/14/数据结构基础/","link":"","permalink":"http://blog.bevexed.top/2019/05/14/数据结构基础/","excerpt":"","text":"数据结构 数据的组织、管理和存储格式 提高数据的访问和修改效率分类 线性结构 数组、链表 栈、对、列、哈希表 树 二叉树 二叉堆 图 其他数据结构 跳表、哈希链表、位图、散列表 数组 array 有限个相同类型变量组成的有序集合 数组中的每一个变量被称为元素 数组是最简单最为常用的数据结构 在内存中顺序存储 读取数组元素和更新数组元素的时间复杂度都是 O(1) 数组的插入和删除操作的时间复杂度为 O(n) 适用于读操作多，写操作少的情景 链表 link list 链表是一种物理上非连续、非顺序的数据结构，由若干个节点(node)组成 链表中的第一个节点叫做节点头，最后一个节点被称为节点尾，尾节点的 next 指针指向空 在内存中随机存储 链表查询节点的最坏时间复杂度为 O(n) 链表更新、插入、删除节点的时间复杂度为 O(1)– 适用于写操作多，读操作少的情景单向链表 单向链表的每一个节点包涵两部分 一部分存放数据变量data 另一部分是指向下一个节点的指针 next 一级一级，单线传递双向链表 每一个节点都拥有 data，next指针 和 prev指针 双向传递 栈 stack 一种线性数据结构 栈中元素只能先入后出（First In Last Out，简称 FILO） 最早进入的元素存放的位置叫栈底（bottom） 最后进入的元素存放的位置叫栈顶（top） 数据结构即可以用数组实现，也可以用链表实现操作 入栈 入栈操作（push）是把新元素放入栈中 只允许从栈顶一侧放入元素 新元素的位置成为新的栈顶 出栈 出栈操作（pop）是把元素从栈中弹出 只有栈顶元素才允许出栈 出栈元素的前一个元素会成为新的栈顶 出栈和入栈的时间复杂度都是 O(1)应用 历史回溯 面包屑导航 队列 queue 一种线性的数据结构 队列中的元素先入先出（First In First Out，简称 FIFO） 队列的出口端叫做队头（front） 队列的入口端叫做队尾（rear）操作 入队 入队（queue）是把新元素放入队列中 只允许在队尾的位置放置新元素 新元素的下一个位置将会成为下一个队尾 出队 出队（dequeue）是把元素移出队列， 只允许在队头一侧移出元素 出队元素后的一个元素将成为队头 队列循环 出队和入队的时间复杂度都是 O(1)应用 多线程，争夺公平锁的等待队列 双端队列 deque 综合栈和队列的优缺点 优先队列 基于二叉堆实现 散列表 也叫哈希表（hash table） 提供了键（key）和值（value）的映射关系 只要给出一个 key,就可以高效的查找他说匹配的 Value，时间复杂度接近于 O(1) 本质是数组，通过哈希函数转换操作 写操作（put） 通过哈希函数，把 key 转换为数值下标 如果下标对应的位置没有元素，将键值对插入到当前位置 当下标对应的位置已经存在元素，就会出现哈希冲突 哈希冲突的主要解决方式是开放寻址法和链表法 读操作（get） 通过哈希函数，把 key 转换为数值下标 通过在链表内匹配 key 值，寻找节点 扩容（resize） 原因 当经过多次元素插入，散列表达到一定饱和度时，key 映射位置发生冲突的概率会逐渐提高 大量元素拥挤在相同的数组下标位置，会形成很长的链表，对后续的读写抄作有很大的性能影响 这时，散列表需要扩展他的长度 过程 扩容，创建一个新的 Entry 空数组，长度是原数组的2倍 重新Hash，遍历原 Entry 数组，把所有的 Entry 重新 Hash 到新数组中","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.bevexed.top/categories/算法/"}],"tags":[]},{"title":"算法","slug":"算法","date":"2019-05-14T08:04:30.000Z","updated":"2019-05-14T09:15:26.719Z","comments":true,"path":"2019/05/14/算法/","link":"","permalink":"http://blog.bevexed.top/2019/05/14/算法/","excerpt":"","text":"算法algorithm 来自数学领域的一个古老概念。 在计算机领域里，指一系列程序指令，用于处理特定的运算和逻辑能力 特性 有简单的也有复杂的 有高效的也有笨拙的 应用领域 运算 求两个数的最大公约数 查找 在数据库执行 SQL语句 排序 电商商品排序 最优决策 A星寻路算法 算法好坏评判标准其中算法好坏有很多标准，其中重要的两大标准是时间复杂度与空间复杂度 渐进时间复杂度 执行算法的时间成本 对算法运行时间长短的量度 若存在函数 f(n)，使得当 n 趋近于无穷大时，T(n)/f(n) 的极限值为不等于零的常数，则称 f(n) 是 T(n) 的同数量级函数。记作 T(n) = O(f(n))，称为 O(f(n))，O 为算法的渐进时间复杂度，简称为时间复杂度推导时间复杂度的基本原则 如果运行时间是常数量级，则用常数1表示 只保留时间函数中的最高阶项 如果最高阶项存在，则省去最高阶项前的系数 当取值足够大时，O(1)&lt; O(logn)&lt; O(n)&lt; O(nlogn)&lt; O(n²) 空间复杂度 执行算法的空间成本 算法在运行过程中临时占用存储空间大小的度量 程序占用空间大小的计算公式记作 S(n)=O(f(n))，其中 n 为问题的规模，f(n)为算法所占存储空间的函数空间复杂度的计算 常量空间 当算法的存储空间大小固定，和输入的规模没有直接的关系时，空间复杂度记作 O(1) 线性空间 当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模 成中比时，空间复杂度记作 O(n) 二维空间 当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模 n 成正比时，空间复杂度记作 O(n²) 递归空间 递归算法的空间复杂度和递归深度成正比","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.bevexed.top/categories/算法/"}],"tags":[]},{"title":"Generator","slug":"Generator","date":"2019-05-13T08:17:55.000Z","updated":"2019-06-12T01:47:32.125Z","comments":true,"path":"2019/05/13/Generator/","link":"","permalink":"http://blog.bevexed.top/2019/05/13/Generator/","excerpt":"","text":"基本概念 Generator函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数不同 语法上，可以将它理解成一个状态机，封装了多个内部状态 执行上，他是一个遍历器对象生成函数。 执行 Generator函数 会返回一个遍历器对象， 返回的遍历器对象可以依次遍历Generator函数内部的每一个状态 形式上，Generator函数是一个普通函数，但是有两个特征： function命令与函数名之间有一个星号 函数体内部使用 yield 语句来定义不同的内部状态123456789// 定义 一个 Generator 函数function* hellow() &#123; yield 'he'; // 状态语句 yield 'll'; yield 'ow'; return 'ending'; // 结束语句&#125; let hw = hellow(); Generator函数的调用方法和普通函数一样。但是， 调用后该函数不会执行 返回的不是函数运行的结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object） 必须调用对象的next方法，使指针移向下一个状态 每次调用next方法，会返回一个包函value和done两个属性的对象。 value：内部状态值 done：布尔值 ，表示是否遍历结束 yield 表达式yield语句就是暂停标志 next方法的运行逻辑 遇到yield就暂停执行后边的操作，并将紧跟其后的表达式的值作为返回对象的value属性值 下一次调用 next方法 时会继续向下执行，知道遇到下一条yield语句 如果没有遇到新的yield语句就一直运行到函数结束，直到return语句为止，并将return语句后面表达式的值作为返回对象的value属性值 如果没有return语句则返回undefined yield语句与return语句 两者都返回紧跟在语句后面的表达式的值 yield语句具有记忆功能，return语句不具有此功能 一个函数只能执行一次return语句，但是可以执行多条yield语句 暂缓执行函数当Generator函数不包含yield语句时，就变成了一个暂缓执行函数1234567function* f() &#123; console.log(1);&#125;let g = f(); // 此时不执行setTimeout(function() &#123; g.next() // 只有调用 next 以后才执行&#125;,3000) 注意事项 yield语句只能用在Generator函数中，用在其他地方会报错 不可以用在 forEach等方法的回调函数内，可以使用for循环代替 yield表达式如果在另一个表达式中，必须放在圆括号内 123function* f() &#123; console.log(1+(yield 2));&#125; yield表达式作为函数参数或放在赋值表达式的右边可以不加括号 与Generator接口的关系 任意一个对象的Symbol.iterator方法等于该对像的遍历器对象生成函数，调用该函数会返回该对象的一个遍历器对象 由于Generator函数就是遍历器生成函数，所以可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口 123456let myIterable = [];myIterable[Symbol.iterator] = function*() &#123; yield 1; yield 2;&#125;;console.log([...myIterable]) // [1, 2] Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身12345function* f() &#123; console.log(1);&#125;let g = f();console.log(g[Symbol.iterator] === g); // true next方法的参数 yield语句本身没有返回值，或者说总是返回undefined next 方法可以带有一个参数，该参数会被当做上一条 yield语句的返回值 由于 next 方法的参数表示上一条yield语句的返回值，所以第一次使用 next 方法时，传递参数是无效的 如果希望第一次调用 next 方法时能过输入值，可以在 Generator函数 外再包一层 for…of循环 for…of 循环可以自动遍历 Generator函数 生成的 Iterator 对象，且此时不需要调用 next 方法。 一旦 next 方法的返回对象的 done 属性为 true，for…of循环就会终止，且不包含返回的对象12345678function* f() &#123; yield 1; yield 2; return 3;&#125;for (let v of foo())&#123; console.log(v); // 1 2 不包含 return语句返回的 3&#125; Generator.prototype.throw() Generator函数返回的遍历器对象都有一个 throw 方法，可以在函数体外抛出错误，然后再 Generator函数 内捕获；反过来，Generator函数体内抛出的错误也可以被函数体外的 catch 捕获 如果 Generator函数 内部没有部署 try…catch 代码块，那么 throw 方法抛出的错误将被外部的 try…catch 代码块捕获 如果 Generator函数 内部部署了 try…catch 代码块，那么遍历器的 throw 方法抛出的错误不影响下一次遍历，否则遍历会终止 一旦Genertator函数执行过程中抛出错误，就不会往下执行了，如果此后调用 next 方法，将返回 {value: undefined, done: true} 这个对象 throw 方法执行后会附带执行下一条 yield 表达式，即附带执行一次 next 方法 throw 命令与 Generator.prototype.throw()方法互不影响12345678910111213141516171819let g = function*() &#123; try &#123; yield ; &#125;catch (e) &#123; console.log('内部捕获',e); &#125;&#125;;let i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125;catch (e) &#123; console.log('外部捕获',e);&#125;// 内部捕获 a// 外部捕获 b Generator.prototype.return() 该方法返回给定的值,并终结Generator函数的遍历 如果不提供参数，则返回值的 value 属性为 undefined 123456789function* f() &#123; yield 1; yield 2;&#125;let g = f();g.next(); // &#123;value: 1, done &#125;g.return('foo'); // &#123;value: 'foo', done: true&#125;g.next() // &#123;value: undefined, deone: true&#125; 如果Generator函数内部有 try…finally 代码块，那么 return 方法会推迟到 finally 代码块执行完成在执行 123456789101112131415161718function* f() &#123; yield 1; try &#123; yield 2; yield 3; &#125; catch (e) &#123; yield 4; yield 5; &#125; yield 6;&#125;let g = f();g.next(); // &#123; value: 1, done: false &#125;g.next(); // &#123; value: 2, done: false&#125;g.return(); // &#123; value: 4, done: false&#125;g.next(); // &#123; value: 5, done: false&#125;g.next(); // &#123; value: 7, done: true&#125; yield* 表达式 如果在一个Generator函数内调用另一个Generator函数，默认情况下是没有效果的 12345678910111213function* a() &#123; yield 'a';&#125;function* b() &#123; a(); yield 'b';&#125;for (let v of b())&#123; console.log(v); // 'b'&#125; // a 和 b 都是 Generator函数 在b中调用a不会生效 yield*，用来在一个Generator函数里执行另一个Generator函数 123456789101112function* a() &#123; yield 'a';&#125;function* b() &#123; yield* a(); yield 'b';&#125;for (let v of b())&#123; console.log(v); // 'a' 'b'&#125; 如果 yield 命令后面跟的是一个遍历器对象，那么需要在 yield 命令后面加上星号，表明返回的是一个遍历器对象 123456789101112131415161718192021222324function* inner() &#123; yield 'hellow'&#125;function* outer1() &#123; yield 'open'; yield inner(); yield 'colse'&#125;let gen = outer1();gen.next().value; // 'open'gen.next().value; // 返回一个遍历器对象gen.next().value; // 'colse'function* outer2() &#123; yield 'open'; yield* inner(); yield 'close';&#125;let gen2 = outer2();gen2.next().value; // 'open'gen2.next().value; // 'hellow'gen2.next().value; // 'close' yield* 后面的Generator语句没有 return 语句时等同于在Generator函数内部部署了一个 for...of 循环 yield 后面的Generator语句有 return 语句时，需要用 `let value = yield iterator` 的形式获取 return语句的值 如果被代理的Generator语句有 return 语句，那么可以向代理他的Generator函数返回数据 任何数据只要有Iterator接口，就可以被yield*遍历123456789101112let a = (function*() &#123; yield 'hellow'; yield* 'he'; yield* [1,2,3] &#125;());a.next().value; // 'hellow'a.next().value; // 'h'a.next().value; // 'e'a.next().value; // '1'a.next().value; // '2'a.next().value; // '3' 应用 异步操作的同步化表达 控制流管理 部署 Iterator 接口 作为数据结构","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.bevexed.top/categories/JavaScript/"}],"tags":[{"name":"异步","slug":"异步","permalink":"http://blog.bevexed.top/tags/异步/"}]},{"title":"函数节流与函数防抖","slug":"函数节流与函数防抖","date":"2019-04-26T02:39:53.000Z","updated":"2019-04-28T02:46:48.482Z","comments":true,"path":"2019/04/26/函数节流与函数防抖/","link":"","permalink":"http://blog.bevexed.top/2019/04/26/函数节流与函数防抖/","excerpt":"","text":"函数节流 throttle 限制一个函数在一定时间内只执行一次 上拉加载 屏幕滚动 高频点击 实现1234567891011121314const _.throttle = (func, wait) =&gt; &#123; let timer; return () =&gt; &#123; if (timer) &#123; return; &#125; timer = setTimeout(() =&gt; &#123; func(); timer = null; &#125;, wait); &#125;;&#125;; 函数防抖 debounce 事件触发后 n秒 内只执行一次，如果 n秒 内再次触发事件，则重新计算函数执行时间 一个动作连续触发，只执行最后一次 应用场景 搜索 手机号、邮箱验证 窗口改变 实现12345678const _.debounce = (func, wait) =&gt; &#123; let timer; return () =&gt; &#123; clearTimeout(timer); timer = setTimeout(func, wait); &#125;;&#125;; 异同比较相同点 都可以通过 setTimeout 实现 都是降低回调执行频率，节省计算资源 不同点 函数防抖，在一段连续操作结束后，处理回调函数，利用 clearTimeout 和 setTimeout 实现。 函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。 函数防抖，关注一段时间连续触发，只在最后一次执行 函数节流，侧重一段时间只执行一次 参考文章 浅析函数防抖与函数节流","categories":[{"name":"性能优化","slug":"性能优化","permalink":"http://blog.bevexed.top/categories/性能优化/"}],"tags":[{"name":"事件监听","slug":"事件监听","permalink":"http://blog.bevexed.top/tags/事件监听/"}]},{"title":"indexedDB","slug":"indexedDB","date":"2019-04-02T10:18:51.000Z","updated":"2019-04-02T10:21:04.052Z","comments":true,"path":"2019/04/02/indexedDB/","link":"","permalink":"http://blog.bevexed.top/2019/04/02/indexedDB/","excerpt":"","text":"特征NoSQL 数据库 不支持 SQL 查询语句 不属于 关系型数据库 键值对存储 采用对象仓库（object store）存放数据 所有数据都可以直接存入，包括 JavaScript对象 每一条数据都有 独一无二的 主键对应，重复会报错 异步 不会锁死浏览器 支持事务（transaction） 只要一步失败，整个事务取消，数据库回滚到事务发生之前的状态 同源限制 每一个数据库都有一个与之对应的域名 不能跨域访问数据库 存储空间大 一般 不小于250M 支持二进制存储 可以存储 ArrayBuffer对象 和 Blob对象 基本概念 数据库：IDBDatabase 对象 对象仓库：IDBObjectStore 对象 索引： IDBIndex 对象 事务： IDBTransaction 对象 操作请求：IDBRequest 对象 指针：IDBCursor 对象 主键集合：IDBKeyRange 对象 数据库 数据库是一些列相关数据的容器。 每个域名（协议+域名+端口）都可以创建任意多个数据库 IndexedDB 数据库有版本的概念,同一时间只能有一个版本的数据库存在。 修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。 对象仓库 每个数据库包涵若干个对象仓库，类似于关系数据库中的表格。 索引 为了加快数据检索，在对象仓库里，为不同属性建立索引。 事务 数据记录的读写和删除，倒要通过事务完成。 事务对象提供 error、abort、complete 三个事件，用来监听操作结果。 数据记录 对象仓库保存的是数据记录。 每条记录类似于关系型数据库的行，但是只有主键和数据体两个部分。 主键用来建立默认的索引，必须是不同的，否则会报错 主键可以是数据记录里面的一个属性，也可以是一个递增的整数编号 操作打开数据库 indexedDB.open() 参数1：数据库名字 指定数据库不存在，新建数据库 参数2：数据库版本 新建数据库版本默认为 1 1const request = window.indexedDB.open('databaseName', version); 返回一个 IDBRequest 对象 该对象通过 error 、 success 、 upgradeneeded 三种事件处理打开数据库的操作结果error123request.onerror = function (event) &#123; console.log('数据库打开报错', event);&#125;; success 通过request对象的result属性拿到数据库对象。 123456let db;request.onsuccess = function (event) &#123; db = request.result; console.log('数据库打开成功');&#125;; upgradeneeded 当指定的版本号大于 实际操作的版本号，触发该事件。 通过事件对象的target.result属性，拿到数据库实例。12345let db;request.onupgradeneeded = function (event) &#123; db = event.target.result;&#125; 新建数据库 新建数据库和打开数据库是同一操作 打开数据库后的后续操作主要在 upgradeneeded 中操作 新建对象仓库 createObjectStore() 参数1：表格名字 参数2：主键配置 { autoIncrement: true } // IndexedDB 自动生成主键。 { keyPath: ‘id’ } // 自定义主键为 ‘id’ 12345678910let dbrequest.onupgradeneeded = function(event) &#123; db = event.target.result; let objectStore; // 检测表格是否 存在 if (!db.objectStoreNames.contains('person')) &#123; // 新建一张叫做 person 的表格 ，主键是 id objectStore = db.createObjectStore('person', &#123; keyPath: 'id' &#125;); &#125;&#125; 创建索引 createIndex() 参数1：索引名称 参数2：索引所在属性 参数1：配置对象 { unique: false } // 该属性是否包涵重复的值123456request.onupgradeneeded = function(event) &#123; let db = event.target.result; let objectStore = db.createObjectStore('person', &#123; keyPath: 'id' &#125;); objectStore.createIndex('name', 'name', &#123; unique: false &#125;); objectStore.createIndex('email', 'email', &#123; unique: true &#125;);&#125; 新增数据 向对象仓库写入数据记录 需要通过新建事务完成 新建时必须指定 表格名城 和 操作模式（‘只读’、‘读写’） 新建事务后 通过 IDBTransaction.objectStore(name) 方法，拿到 IDBObjectStore 对象 通过 add() 方法向表格 写入数据 写入操作是一个 异步操作，通过监听链接对象的 success 和 error 事件，判断是否写入成功 12345678910111213function add() &#123; let request = db.transaction(['person'], 'readwrite') .objectStore('person') .add(&#123; id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' &#125;); request.onsuccess = function (event) &#123; console.log('数据写入成功', event); &#125;; request.onerror = function (event) &#123; console.log('数据写入失败', event); &#125;&#125; 读取数据 读取数据也通过事务完成12345678910111213141516171819function read() &#123; let transaction = db.transaction(['person']); let objectStore = transaction.objectStore('person'); let request = objectStore.get(1); request.onerror = function(event) &#123; console.log('事务失败'); &#125;; request.onsuccess = function(event) &#123; if (request.result) &#123; console.log('Name: ' + request.result.name); console.log('Age: ' + request.result.age); console.log('Email: ' + request.result.email); &#125; else &#123; console.log('未获得数据记录'); &#125; &#125;;&#125; 遍历数据 openCursor() 遍历数据表格的所有记录，要使用指针对象 IDBCursor openCursor() 方法是一个异步操作，需要监听 success 事件返回的结果1234567891011121314151617function readAll() &#123; let objectStore = db.transaction('person').objectStore('person'); objectStore.openCursor().onsuccess = function (event) &#123; let cursor = event.target.result; if (cursor) &#123; console.log('Id: ' + cursor.key); console.log('Name: ' + cursor.value.name); console.log('Age: ' + cursor.value.age); console.log('Email: ' + cursor.value.email); cursor.continue(); &#125; else &#123; console.log('没有更多数据了！'); &#125; &#125;;&#125; 更新数据 IDBObject.put()12345678910111213function update() &#123; let request = db.transaction(['person'], 'readwrite') .objectStore('person') .put(&#123; id: 1, name: '李四', age: 35, email: 'lisi@example.com' &#125;); request.onsuccess = function (event) &#123; console.log('数据更新成功'); &#125;; request.onerror = function (event) &#123; console.log('数据更新失败'); &#125;&#125; 删除数据 openCursor()123456789function remove() &#123; let request = db.transaction(['person'], 'readwrite') .objectStore('person') .delete(1); request.onsuccess = function (event) &#123; console.log('数据删除成功'); &#125;;&#125; 使用索引 索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录 123456789101112131415objectStore.createIndex('name', 'name', &#123; unique: false &#125;);let transaction = db.transaction(['person'], 'readonly');let store = transaction.objectStore('person');let index = store.index('name');let request = index.get('李四');request.onsuccess = function (e) &#123; let result = e.target.result; if (result) &#123; // ... &#125; else &#123; // ... &#125;&#125; indexedDB 对象 浏览器提供的原生对象 indexedDB.open() 打开数据库 异步操作 立即返回一个 IDBOpenDBRequest 对象 12// 打开一个名为 test 版本为 1 的数据库，如果数据库不存在则创建该数据库let openRequest = window.indexedDB.open('test', 1); 参数 参数1：数据库名称 格式为字符串，不可省略 参数2：数据库版本 大于 0 的正整数 ，0 会报错 该参数大于当前版本，会触发数据库升级 该参数可以省略，如果数据库已存在，打开最新版本数据库；如果数据库不存在，创建该版本的数据库，默认版本为 1 回调事件 success：打开成功 error：打开失败 upgradeneeded：第一次打开该数据库，或数据库版本发生变化 blocked：上一次的数据库连接还未关闭 第一次打开数据库，会先触发 upgradeneeded 事件，然后触发 success 事件success 事件发生后，从 openRequest.result 属性可以拿到已经打开的 IndexedDB 数据库对象 12345678910111213141516let openRequest = indexedDB.open('test', 1);let db;openRequest.onupgradeneeded = function (e) &#123; console.log('Upgrading...');&#125;openRequest.onsuccess = function (e) &#123; console.log('Success!'); db = openRequest.result;&#125;openRequest.onerror = function (e) &#123; console.log('Error'); console.log(e);&#125; indexedDB.deleteDatabase() 用于删除一个数据库 立即返回一个 IDBOpenDBRequest 对象，然后对数据库执行异步删除 删除不存在的数据库时，不会报错 当调用该方法后，当前数据的其他已经打开的连接都会接收到 versionchange 事件 参数 数据库名字 回调事件 success：删除成功 error：删除失败123456789let DBDeleteRequest = window.indexedDB.deleteDatabase('demo');DBDeleteRequest.onerror = function (event) &#123; console.log('Error');&#125;;DBDeleteRequest.onsuccess = function (event) &#123; console.log('success');&#125;; indexedDB，cmp() 比较两个值是否为 indexedDB 的相同的主键。 返回一个整数，表示比较的结果 0 ：相同 1： 第一个主键大于第二个主键 -1： 第一个主键小于第二个主键1234window.indexedDB.cmp(1, 2); // -1// 注意，这个方法不能用来比较任意的 JavaScript 值。如果参数是布尔值或对象，它会报错。window.indexedDB.cmp(1, true); // 报错window.indexedDB.cmp(&#123;&#125;, &#123;&#125;) // 报错 IDBRequest 对象 表示打开的数据库连接 indexedDB.open() 和 indexedDB.deleteDatabase() 方法会返回这个对象 数据库的操作都是通过此对象完成 对象的所有操作都是 异步 完成 通过 readyState 属性判断是否完成 pending：正在进行 done：完成，有可能失败也有可成功 操作完成，触发 error 或 success 事件 可以通过 result 属性 和 error 属性 拿到操作结果 如果在 pending 状态去读取这两个属性的值会报错属性 IDBRequest.readyState：等于pending表示操作正在进行，等于done表示操作正在完成。 IDBRequest.result：返回请求的结果。如果请求失败、结果不可用，读取该属性会报错。 IDBRequest.error：请求失败时，返回错误对象。 IDBRequest.source：返回请求的来源（比如索引对象或 ObjectStore）。 IDBRequest.transaction：返回当前请求正在进行的事务，如果不包含事务，返回null。 IDBRequest.onsuccess：指定success事件的监听函数。 IDBRequest.onerror：指定error事件的监听函数。 插件level.js","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.bevexed.top/categories/HTML5/"}],"tags":[]},{"title":"browser-sync 安装与使用","slug":"browser-sync","date":"2019-04-02T06:35:48.000Z","updated":"2019-04-02T06:42:54.317Z","comments":true,"path":"2019/04/02/browser-sync/","link":"","permalink":"http://blog.bevexed.top/2019/04/02/browser-sync/","excerpt":"","text":"browser-sync 浏览器同步工具 安装1&gt; npm i browser-sync -g 使用1&gt; browser-sync init 普通使用1&gt; browser-sync start --server --files \"**\" 跨域1&gt; browser-sync start --proxy \"localhost:8080\" --files \"**\"","categories":[{"name":"构建工具","slug":"构建工具","permalink":"http://blog.bevexed.top/categories/构建工具/"}],"tags":[]},{"title":"rc-queue-anim的使用","slug":"rc-queue-anim的使用","date":"2019-02-18T01:56:50.000Z","updated":"2019-02-18T02:06:37.337Z","comments":true,"path":"2019/02/18/rc-queue-anim的使用/","link":"","permalink":"http://blog.bevexed.top/2019/02/18/rc-queue-anim的使用/","excerpt":"","text":"安装1&gt; npm i -S rc-queue-anim 使用harmony12345678910import QueueAnim from 'rc-queue-anim';ReactDOM.render( &lt;QueueAnim delay=&#123;300&#125; className=\"queue-simple\"&gt; &lt;div key=\"a\"&gt;依次进场&lt;/div&gt; &lt;div key=\"b\"&gt;依次进场&lt;/div&gt; &lt;div key=\"c\"&gt;依次进场&lt;/div&gt; &lt;div key=\"d\"&gt;依次进场&lt;/div&gt; &lt;/QueueAnim&gt;, mountNode); 官网https://motion.ant.design/","categories":[{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/categories/React/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://blog.bevexed.top/tags/插件/"},{"name":"动画","slug":"动画","permalink":"http://blog.bevexed.top/tags/动画/"}]},{"title":"socket.io","slug":"socket-io","date":"2019-02-15T05:46:52.000Z","updated":"2019-04-26T02:48:36.644Z","comments":true,"path":"2019/02/15/socket-io/","link":"","permalink":"http://blog.bevexed.top/2019/02/15/socket-io/","excerpt":"","text":"安装1&gt; npm install socket.io -S 使用客户端12345678910111213import io from 'socket.io-client'// 得到与服务器的链接对象const socket = io('ws://localhost:9000');// 接收消息socket.on('receiveMsg', function (data) &#123; console.log('浏览器接收消息');&#125;)// 发送消息socket.emit('sendMsg', &#123;name: '12', data: Date.now()&#125;)console.log('发送消息'); 服务端123456789101112131415161718module.exports = function (server) &#123; const io = require('socket.io')(server); // 监视客户端与服务器端的链接 io.on('connection',function (socket) &#123; console.log('链接成功'); socket.on('sendMsg',function (data) &#123; console.log('服务器接受到浏览器消息'); // 全局发数据 io.emit('receiveMsg',data.name+'_'+data.data) // 单一发数据 socket.emit('receiveMsg',data.name+'_'+data.data) console.log('服务器向浏览器发消息'); &#125;) &#125;)&#125;// wwwrequire('../socketIO/test')(server); 参考网站 https://socket.io/get-started/chat/ https://blog.csdn.net/neuq_zxy/article/details/77531126","categories":[{"name":"Node","slug":"Node","permalink":"http://blog.bevexed.top/categories/Node/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://blog.bevexed.top/tags/插件/"},{"name":"Node","slug":"Node","permalink":"http://blog.bevexed.top/tags/Node/"}]},{"title":"js-cookie","slug":"js-cookie","date":"2019-02-14T03:48:21.000Z","updated":"2019-02-14T03:54:28.798Z","comments":true,"path":"2019/02/14/js-cookie/","link":"","permalink":"http://blog.bevexed.top/2019/02/14/js-cookie/","excerpt":"","text":"安装1&gt; yarn add js-cookie -S cdn1&lt;script src=\"https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js\"&gt;&lt;/script&gt; 使用1import Cookies from 'js-cookie' apiCookies.set123Cookies.set('name', 'value');Cookies.set('name', 'value', &#123; expires: 7 &#125;);Cookies.set('name', 'value', &#123; expires: 7, path: '' &#125;); Cookies.get123Cookies.get('name'); // =&gt; 'value'Cookies.get('nothing'); // =&gt; undefinedCookies.get(); // =&gt; &#123; name: 'value' &#125; Cookies.remove1Cookies.remove('name'); 参考网站https://www.npmjs.com/package/js-cookie","categories":[{"name":"插件","slug":"插件","permalink":"http://blog.bevexed.top/categories/插件/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://blog.bevexed.top/tags/插件/"},{"name":"cookie","slug":"cookie","permalink":"http://blog.bevexed.top/tags/cookie/"}]},{"title":"redux的使用","slug":"redux的使用","date":"2019-02-13T06:11:39.000Z","updated":"2019-02-18T02:29:31.976Z","comments":true,"path":"2019/02/13/redux的使用/","link":"","permalink":"http://blog.bevexed.top/2019/02/13/redux的使用/","excerpt":"","text":"文档 https://www.redux.org.cn/ redux 模块 redux模块整体是一个对象模块 内部包含的函数： createStore(reducers) // reducers:fucntion(state,action)(return newState) combineReducers(reducers) // reducers:{reducer1,reducer2} 返回：function(state,action){rteturn newState} applyMiddleware() 安装基本包1&gt; npm install --save redux react-redux redux-thunk redux-devtools-extension 开发工具1npm install --save-dev redux-devtools 使用目录结构reduxstore.jsredux 最核心的管理模块1234567import &#123;createStore,applyMiddleware&#125; from \"redux\";import thunk from 'redux-thunk'import &#123;composeWithDevTools&#125; from \"redux-devtools-extension\";import reducers from './reducers'// 向外暴露 store 对象export default createStore(reducers,composeWithDevTools(applyMiddleware(thunk))) reducers.js包含 n 个 reducer 函数 根据老的 state 和 指定的 action 返回一个 新的 state1234567891011121314151617// 合并状态import &#123;combineReducers&#125; from \"redux\"; import &#123;AUTH_SUCCESS, ERROR_MSG&#125; from \"./action-types\";export const register = (user) =&gt; &#123; return async dispatch =&gt; &#123; // 发送注册的异步 ajax 请求 const result = await reqRegister(user) console.log(result); if (result.code === 0) &#123; // 分发成功的同步action dispatch(authSuccess(result.data)) &#125; else &#123; dispatch(errprMsg(result.msg)) &#125; &#125;&#125; actioncs.js包含 n 个 action creator 异步 action 同步 action 1234import &#123; AUTH_SUCCESS, ERROR_MSG&#125; from \"./action-types\"; action-types.js包含 n 个 action-type 常量12export const AUTH_SUCCESS='auth_success'export const ERROR_MSG='error_msg' app.js引入Provider、storejsx12345678910111213141516171819import &#123;Provider&#125; from 'react-redux'import store from './redux/store'class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;Provider store=&#123;store&#125;&gt; &lt;HashRouter&gt; &lt;Switch&gt; &lt;Route exact path='/register' component=&#123;Register&#125;/&gt; &lt;Route exact path='/login' component=&#123;Login&#125;/&gt; &lt;Route component=&#123;Main&#125;/&gt; &#123;/* 默认组件*/&#125; &lt;/Switch&gt; &lt;/HashRouter&gt; &lt;/Provider&gt; &lt;/div&gt; ); &#125;&#125; 参考文章Redux 入门教程 https://cn.vuejs.org/v2/guide/state-management.html https://vuex.vuejs.org/ https://cn.redux.js.org/docs/react-redux/ http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html https://redux-saga-in-chinese.js.org https://juejin.im/post/59e6cd68f265da43163c2821 https://react-redux.js.org/introduction/why-use-react-redux https://segmentfault.com/a/1190000007248878 http://es6.ruanyifeng.com/#docs/generator https://juejin.im/post/5ac1cb9d6fb9a028cf32a046 https://zhuanlan.zhihu.com/p/35437092 https://github.com/dvajs/dva/issues/1 https://cn.mobx.js.org https://zhuanlan.zhihu.com/p/25585910 http://imweb.io/topic/59f4833db72024f03c7f49b4","categories":[{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/categories/React/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://blog.bevexed.top/tags/插件/"},{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/tags/React/"}]},{"title":"react技术选型","slug":"react技术选型","date":"2019-02-13T05:40:52.000Z","updated":"2019-02-13T08:04:12.452Z","comments":true,"path":"2019/02/13/react技术选型/","link":"","permalink":"http://blog.bevexed.top/2019/02/13/react技术选型/","excerpt":"","text":"前台数据展示/交互/组件化react-router-dom npm i react-router-dom -S redux npm i redux react-redux redux-thunk redux-devtools-extension -S antd-mobile npm i -D babel-plugin-import react-app-rewired 引入 看文档 按需打包 后台项目 node express mongodb mongoose socket.io 前后台交互 ajax 请求 axios async / await测试 API 接口 postman模块化 ES6 babel 项目构建/工程化 webpack react-create-app eslint 其他相关库 blueimp-md5 js-cookie rc-queue-anim","categories":[{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/categories/React/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://blog.bevexed.top/tags/插件/"},{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/tags/React/"}]},{"title":"react-router-dom的简单使用","slug":"react-router-dom的使用","date":"2019-02-13T02:19:28.000Z","updated":"2019-02-15T07:38:11.389Z","comments":true,"path":"2019/02/13/react-router-dom的使用/","link":"","permalink":"http://blog.bevexed.top/2019/02/13/react-router-dom的使用/","excerpt":"","text":"安装1&gt; yarn add react-router react-router-dom -S 引入1import &#123;Swtich, Route, Router, HashHistory, Link&#125; from 'react-router-dom'; 简单使用1234567&lt;HashRouter&gt; &lt;Switch&gt; &lt;Route exact path='/' component=&#123;home&#125;&gt;1212&lt;/Route&gt; &lt;Route exact path='/a' component=&#123;a&#125;&gt;12321312&lt;/Route&gt; &lt;Route component=&#123;a&#125;&gt;12321312&lt;/Route&gt; &#123;/* 默认组件*/&#125; &lt;/Switch&gt;&lt;/HashRouter&gt; API https://reacttraining.com/react-router/web/api/BrowserRouter &lt;Router>history: objectchildren: node&lt;BrowserRouter>basename: string所有位置的基准 URL。 如果你的应用程序部署在服务器的子目录，则需要将其设置为子目录。 basename 的正确格式是前面有一个前导斜杠，但不能有尾部斜杠。 getUserConfirmation: funcforceRefresh: bool强制刷新页面 keyLength: numberchildren: node&lt;HashRouter>basename: stringgetUserConfirmation: funchashtype: string slash: #/ noslash: # hashbang: #!children: node &lt;StaticRouter>basename: stringlocation: stringlocation: objectcontext: objectchildren: node&lt;MemoruRouter>initialEntries: arrayinitialIndex: numbergetUserConfirmation: funckeylength: numberchildren: node&lt;Link>to: stringto: object pathname: url search: query hash: # state: {} replace: funcinnerRef: funcothers &lt;NavLink>activeClassName: stringactiveStyle: objectexact: boolstrict: boolisActive: funclocation: object&lt;Prompt>用于在位置跳转之前给予用户一些确认信息。当你的应用程序进入一个应该阻止用户导航的状态时（比如表单只填写了一半），弹出一个提示。 message: stringmessage: funcwhen: bool&lt;Redirect>to: stringto: objectpush: boolfrom: stringexact: boolstrict: bool&lt;Switch>location: objectchildren: nodewithRouter将非路由组件变成路由组件12import &#123;withRouter&#125; from 'react-router-dom'export default withRouter(`组件名`) 编程式导航history在props上有history对象，这个对象上存在多个个方法 push replace","categories":[{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/categories/React/"}],"tags":[{"name":"Route","slug":"Route","permalink":"http://blog.bevexed.top/tags/Route/"}]},{"title":"vue查漏补缺","slug":"vue查漏补缺","date":"2019-02-11T08:59:36.000Z","updated":"2019-06-12T04:00:07.527Z","comments":true,"path":"2019/02/11/vue查漏补缺/","link":"","permalink":"http://blog.bevexed.top/2019/02/11/vue查漏补缺/","excerpt":"","text":"Vue 不支持 IE8 及以下版本CDN1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.22/dist/vue.js\"&gt;&lt;/script&gt; key确保相同的元素被切换时会重新渲染 v-for 可以对对象的属性进行迭代 提供了 value、 key、 index 三个参数 12345&lt;ul id=\"v-for-object\" class=\"demo\"&gt; &lt;li v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678910new Vue(&#123; el: '#v-for-object', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125;&#125;) 数组的更新检测 push() pop() shift() unshift() splice() sort() reverse() 注意事项由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如： 1234567vm.items[indexOfItem] = newValue// 通过一下方法替代// Vue.setVue.set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 当你修改数组的长度时，例如： 1vm.items.length = newLength 修饰符事件处理 .stop .prevent .capture .self .once .passive 按键 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 系统 .ctrl .alt .shift .meta 鼠标 .left .right .middle 表单 .lazy .trim .number slot具名slot 模板123&lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt;&lt;/header&gt; 使用1234// template 可以是任意元素 &lt;template slot=\"header\"&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt; 动画过渡类名 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://blog.bevexed.top/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.bevexed.top/tags/Vue/"},{"name":"修饰符","slug":"修饰符","permalink":"http://blog.bevexed.top/tags/修饰符/"}]},{"title":"Vue微信支付授权的坑（当前页面的URL未注册）","slug":"vue微信支付授权（一）","date":"2019-02-11T05:45:11.000Z","updated":"2019-02-13T06:05:17.564Z","comments":true,"path":"2019/02/11/vue微信支付授权（一）/","link":"","permalink":"http://blog.bevexed.top/2019/02/11/vue微信支付授权（一）/","excerpt":"","text":"获取微信授权的URL微信支付之前都要获取微信授权，由于微信对 IOS 和 Android 的 URL 的处理不同，所以这里统一使用这个方法获取授权时使用的 URL1let url = window.location.href.split('#')[0]; ? 的作用尽管你向后台发送了被#截取过的授权URL，但是在真正支付的时候，你或许还是会看到 URL未注册的情况。 解决问题 这个时候请大胆的在当前的页面的#前面拼接? 微信在检验URL的时候，如果URL字符串内有?,会将?前的所有内容全部截取 如果?出现在#后，会导致#前的内容也被截取，从而导致认证失败 所以这里通过提前加?的方式避开了认证地址截取过多的问题","categories":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://blog.bevexed.top/categories/微信公众号/"}],"tags":[{"name":"微信","slug":"微信","permalink":"http://blog.bevexed.top/tags/微信/"},{"name":"Vue","slug":"Vue","permalink":"http://blog.bevexed.top/tags/Vue/"},{"name":"授权","slug":"授权","permalink":"http://blog.bevexed.top/tags/授权/"}]},{"title":"使用vue-property-decorator","slug":"使用vue-property-decorator","date":"2019-02-01T02:41:10.000Z","updated":"2019-06-12T04:00:22.055Z","comments":true,"path":"2019/02/01/使用vue-property-decorator/","link":"","permalink":"http://blog.bevexed.top/2019/02/01/使用vue-property-decorator/","excerpt":"","text":"@Emit@Emit(event?: string) decorator123456789101112131415161718192021222324252627282930import &#123; Vue, Component, Emit &#125; from 'vue-property-decorator'@Componentexport default class YourComponent extends Vue &#123; count = 0 @Emit() addToCount(n: number) &#123; this.count += n &#125; @Emit('reset') resetCount() &#123; this.count = 0 &#125; @Emit() returnValue() &#123; return 10 &#125; @Emit() promise() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(20) &#125;, 0) &#125;) &#125;&#125; 等价于12345678910111213141516171819202122232425262728293031export default &#123; data() &#123; return &#123; count: 0 &#125; &#125;, methods: &#123; addToCount(n) &#123; this.count += n this.$emit('add-to-count', n) &#125;, resetCount() &#123; this.count = 0 this.$emit('reset') &#125;, returnValue() &#123; this.$emit('return-value', 10) &#125;, promise() &#123; const promise = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(20) &#125;, 0) &#125;) promise.then(value =&gt; &#123; this.$emit('promise', value) &#125;) &#125; &#125;&#125; @Inject@Model@Model(event?: string, options: (PropOptions | Constructor[] | Constructor) = {}) decorator123456import &#123; Vue, Component, Model &#125; from 'vue-property-decorator'@Componentexport default class YourComponent extends Vue &#123; @Model('change', &#123; type: Boolean &#125;) checked!: boolean&#125; 等价于1234567891011export default &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: &#123; type: Boolean &#125;, &#125;,&#125; @Prop@Prop(options: (PropOptions | Constructor[] | Constructor) = {}) decorator12345678import &#123; Vue, Component, Prop &#125; from 'vue-property-decorator'@Componentexport default class YourComponent extends Vue &#123; @Prop(Number) propA!: number @Prop(&#123; default: 'default value' &#125;) propB!: string @Prop([String, Boolean]) propC!: string | boolean&#125; 等价于12345678910111213export default &#123; props: &#123; propA: &#123; type: Number &#125;, propB: &#123; default: 'default value' &#125;, propC: &#123; type: [String, Boolean] &#125;, &#125;&#125; @Provide@Provide(key?: string | symbol) / @Inject(options?: { from?: InjectKey, default?: any } | InjectKey) decorator123456789101112131415import &#123; Component, Inject, Provide, Vue &#125; from 'vue-property-decorator'const symbol = Symbol('baz')@Componentexport class MyComponent extends Vue &#123; @Inject() foo!: string @Inject('bar') bar!: string @Inject(&#123; from: 'optional', default: 'default' &#125;) optional!: string @Inject(symbol) baz!: string @Provide() foo = 'foo' @Provide('bar') baz = 'bar'&#125; 等价于1234567891011121314151617181920212223const symbol = Symbol('baz')export const MyComponent = Vue.extend(&#123; inject: &#123; foo: 'foo', bar: 'bar', 'optional': &#123; from: 'optional', default: 'default' &#125;, [symbol]: symbol &#125;, data () &#123; return &#123; foo: 'foo', baz: 'bar' &#125; &#125;, provide () &#123; return &#123; foo: this.foo, bar: this.baz &#125; &#125;&#125;) @Watch@Watch(path: string, options: WatchOptions = {}) decorator12345678910111213import &#123; Vue, Component, Watch &#125; from 'vue-property-decorator'@Componentexport default class YourComponent extends Vue &#123; @Watch('child') onChildChanged(val: string, oldVal: string) &#123; &#125; @Watch('person', &#123; immediate: true, deep: true &#125;) onPersonChanged1(val: Person, oldVal: Person) &#123; &#125; @Watch('person') onChildChanged2(val: Person, oldVal: Person) &#123; &#125;&#125; 等价于12345678910111213141516171819202122232425262728export default &#123; watch: &#123; 'child': [ &#123; handler: 'onChildChanged', immediate: false, deep: false &#125; ], 'person': [ &#123; handler: 'onPersonChanged1', immediate: true, deep: true &#125;, &#123; handler: 'onPersonChanged2', immediate: false, deep: false &#125; ] &#125;, methods: &#123; onChildChanged(val, oldVal) &#123; &#125;, onPersonChanged1(val, oldVal) &#123; &#125; onPersonChanged2(val, oldVal) &#123; &#125; &#125;&#125; 注意事项 父组件的函数的参数问题 @Component (provided by vue-class-component)@Component({ components: { HelloWorld, },}) Mixins (the helper function named mixins provided by vue-class-component)参考https://github.com/kaorun343/vue-property-decorator","categories":[{"name":"Vue","slug":"Vue","permalink":"http://blog.bevexed.top/categories/Vue/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.bevexed.top/tags/TypeScript/"}]},{"title":"Vue-cli搭建基于typeScript的Vue项目","slug":"Vue-cli搭建基于typeScript的Vue项目","date":"2019-02-01T02:09:14.000Z","updated":"2019-06-12T03:59:40.569Z","comments":true,"path":"2019/02/01/Vue-cli搭建基于typeScript的Vue项目/","link":"","permalink":"http://blog.bevexed.top/2019/02/01/Vue-cli搭建基于typeScript的Vue项目/","excerpt":"","text":"安装 Vue-cli1&gt; npm install -g @vue/cli 生成项目选一个文件夹1&gt; vue create &lt;项目名称&gt; 配置项目选择 Manually select features123? Please pick a preset: default (babel, eslint) ❯ Manually select features // 选这个 配置具体选项这里根据具体情况选择,因为要使用 TypeScript,所以务必选上1234567891011? Please pick a preset: Manually select features? Check the features needed for your project: ◉ Babel ◉ TypeScript ◯ Progressive Web App (PWA) Support ◯ Router ◯ Vuex❯◯ CSS Pre-processors ◉ Linter / Formatter ◯ Unit Testing ◯ E2E Testing 参考文章教你搭建基于typescript的vue项目","categories":[{"name":"Vue","slug":"Vue","permalink":"http://blog.bevexed.top/categories/Vue/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.bevexed.top/tags/TypeScript/"}]},{"title":"React基本操作","slug":"React基本操作","date":"2019-01-30T07:57:47.000Z","updated":"2019-02-13T02:21:17.697Z","comments":true,"path":"2019/01/30/React基本操作/","link":"","permalink":"http://blog.bevexed.top/2019/01/30/React基本操作/","excerpt":"","text":"安装1&gt; npm install -g create-react-app 创建1&gt; create-react-app 安装插件12&gt; yarn init&gt; yarn add react react-dom 补充修改端口1&#123;\"start\": \"PORT=9000 react-scripts start\"&#125;","categories":[{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/categories/React/"}],"tags":[]},{"title":"ubuntu 18.04 安装配置Nginx","slug":"安装配置Nginx","date":"2019-01-29T03:44:14.000Z","updated":"2019-06-12T05:24:55.890Z","comments":true,"path":"2019/01/29/安装配置Nginx/","link":"","permalink":"http://blog.bevexed.top/2019/01/29/安装配置Nginx/","excerpt":"","text":"安装1&gt; apt install nginx 配置防火墙1&gt; sudo ufw app list 输入命令后，你会看到12345Available applications: Nginx Full 这个配置打开 80端口和443端口 Nginx HTTP 这个配置只打开80 (普通, 未加密通信) Nginx HTTPS 这个配置只打开 443 (TLS/SSL 加密通信) OpenSSH 打开服务1&gt; sudo ufw allow 'Nginx Full' 查看服务是否打开验证服务状态1&gt; sudo ufw status 检查 web server1&gt; systemctl status nginx 通过 IP 访问输入你的网站IP即可 管理 Nginx进程停止1&gt; sudo systemctl stop nginx 启动1&gt; sudo systemctl start nginx 重启1&gt; sduo systemctl restart nginx 开机启动1&gt; sudo systemctl enable nginx 禁止开机启动1&gt; sudo systemctl disable nginx 配置网站文件位置 /var/www/html 修改网站根目录 进入Nginx配置文件 1&gt; sudo vim /etc/nginx/sites-available/default 将 root 所对应网站根目录进行修改 成你的目录 重启nginx1&gt; sudo systemctl restart nginx 服务器配置配置文件目录 /etc/nginx: nginx主配置文件 /etc/nginx/nginx.conf 参考文章http://www.nginx.cn/4723.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://blog.bevexed.top/categories/服务器/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.bevexed.top/tags/Nginx/"}]},{"title":"documentElement 与 body","slug":"documentElement与body","date":"2019-01-23T08:08:53.000Z","updated":"2019-06-12T05:26:34.567Z","comments":true,"path":"2019/01/23/documentElement与body/","link":"","permalink":"http://blog.bevexed.top/2019/01/23/documentElement与body/","excerpt":"","text":"documentElement 与 bodydocument.documentElement 返回 htmldom 中的 root 节点 document.body 返回 htmldom 中的 body 节点 差异scrollTop iso 上两者都可以获取 scrollTop，但是只有body可以设置该值兼容解决方案 对两则同时赋值 123let top = 100document.documentElement.scrollTop = topdocument.body.scrollTop = top","categories":[{"name":"DOM","slug":"DOM","permalink":"http://blog.bevexed.top/categories/DOM/"}],"tags":[{"name":"Scroll","slug":"Scroll","permalink":"http://blog.bevexed.top/tags/Scroll/"}]},{"title":"微信公众号授权","slug":"微信公众号授权","date":"2019-01-22T05:47:34.000Z","updated":"2019-02-13T02:20:48.300Z","comments":true,"path":"2019/01/22/微信公众号授权/","link":"","permalink":"http://blog.bevexed.top/2019/01/22/微信公众号授权/","excerpt":"","text":"微信网页授权资源微信公众平台开发者文档： https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842 具体操作网页授权回调域名 在 “开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息” 的配置选项中，修改授权回调域名 这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头； 授权回调域名不允许跨域 前端部分用户同意授权，获取code 前端只要处理这一步就可以了 接口 https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 参数 参数 是否必须 说明 appid 是 公众号唯一标识 redirect_uri 是 授权后重定向的回调链接地址， 请使用 urlEncode 对链接进行处理 response_type 是 返回类型，请填写code scope 是 应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息 ） state 否 重定向后会带上state参数，开发者可以填写a-zA-Z0-9的参数值，最多128字节 #wechat_redirect are neat 无论直接打开还是做页面302重定向时候，必须带此参数 回调 授权成功后，微信会在新的回调页面的url上拼接code 通过query再url中拿到code,传递给后端即可 后端部分通过code换取网页授权access_token刷新access_token（如果需要）拉取用户信息(需scope为 snsapi_userinfo)检验授权凭证（access_token）是否有效","categories":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://blog.bevexed.top/categories/微信公众号/"}],"tags":[{"name":"微信","slug":"微信","permalink":"http://blog.bevexed.top/tags/微信/"},{"name":"授权","slug":"授权","permalink":"http://blog.bevexed.top/tags/授权/"}]},{"title":"gulp 学习","slug":"gulp","date":"2019-01-21T09:32:53.000Z","updated":"2019-04-12T10:14:54.094Z","comments":true,"path":"2019/01/21/gulp/","link":"","permalink":"http://blog.bevexed.top/2019/01/21/gulp/","excerpt":"","text":"Gulp 任务化Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。 基于流Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务的 Gulp 文件都是通过 JavaScript（或者 CoffeeScript ）源码来实现的。 安装全局安装1&gt; npm install -g gulp 局部安装1&gt; npm install -S gulp 使用 在项目根目录下创建一个名为 gulpfile.js 的文件： 3.012345const gulp = require('gulp');gulp.task('something', function() &#123; // 将你的默认的任务代码放在这&#125;); 4.012345678const gulp = require('gulp');gulp.task('default', gulp.series( // 任务),function() &#123; // 将你的默认的任务代码放在这&#125;); 运行1$ gulp 常用插件 都需要 npm 安装到依赖中 -S gulp-connect 自动打开浏览器 gulp-concat 合并 js/css 文件 gulp-uglify 压缩 js 文件 gulp-babel 将es6转换为es5 gulp-rename 文件重命名 gulp-less 编译 less gulp-clean-css 压缩 css gulp-rev &amp; gulp-rev-collector 为文件加上版本号，并且自动修改html中关于压缩文件的引用路径 gulp-livereload 实时自动编译刷新 gulp-htmlmin 压缩 HTML gulp-load-plugins 万用插件gulp-load-plugins 是依赖 package.json 文件来加载插件的，所以请确保你需要的插件已经加入 package.json 文件并已经安装完毕。 常用 APIgulp.task 注册任务 3.0 gulp.task(name[, deps], fn) name : 任务名不要带空格 deps ： type ：Array 一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。 fn : 回调函数4.0 gulp.task(parallel and series, fn) gulp4不再能够通过数组形式传入任务，你需要使用gulp.series()和gulp.parallel()来执行他们 parallel 异步任务 series 同步任务12gulp.task('default',gulp.parallel('taskA','taskB'));//并行执行gulp.task('default',gulp.series('taskA','taskB'));//按顺序执行 gulp.watch 监视任务 实例 所需组件请自行引入 合并 压缩 JS 任务1234567891011const concat = require('gulp-concat')const uglify = require('gulp-uglify')gulp.task('concatJs',function() &#123; // 有 return 是异步，无 return 是同步 return gulp.src('路径') // 将数据读取到内存中 .pipe(concat('临时合并文件名')) // 临时合并文件 .pipe(uglify()) // 压缩文件 .pipe(rename(&#123;suffix:'.min'&#125;)) // 改名 .pipe(gulp.dest('输出文件目录')) // 输出文件&#125;) 合并 压缩 CSS 任务12345678910111213141516const cssClean = require('gulp-clean-css');const less = require('gulp-less');// 编译less为cssgulp.task('less',function() &#123; return gulp.src('路径') // 将数据读取到内存中 .pipe(less()) // 编译less为css&#125;)// 合并并压缩 css文件gulp.task('css',['less'],function() &#123; return gulp.src('路径') // 将数据读取到内存中 .pipe(concat('临时合并文件名')) // 合并文件 .pipe(rename(&#123;suffix:'.min'&#125;)) // 改名 .pipe(cssClean(&#123;compatibility:'ie8'&#125;)) .pipe(gulp.dest('输出文件目录')) // 输出文件&#125;) 压缩 HTML1234567const htmlMin = require('gulp-htmlmin')gulp.task('less',function() &#123; return gulp.src('路径') // 将数据读取到内存中 .pipe(htmlMin(&#123;collaspeWhitespace:true&#125;)) // 压缩 HTML .pipe(gulp.dest('输出文件目录'))&#125;) 注意项return任务注册时有return 任务异步 任务结束后释放内存 任务中无return 任务同步 任务结束后，不会释放内存","categories":[{"name":"构建工具","slug":"构建工具","permalink":"http://blog.bevexed.top/categories/构建工具/"}],"tags":[{"name":"Gulp","slug":"Gulp","permalink":"http://blog.bevexed.top/tags/Gulp/"}]},{"title":"TypeScript","slug":"typeScript","date":"2019-01-21T09:21:43.000Z","updated":"2019-06-11T09:57:07.442Z","comments":true,"path":"2019/01/21/typeScript/","link":"","permalink":"http://blog.bevexed.top/2019/01/21/typeScript/","excerpt":"","text":"TypeScript JavaScript 的超集 微软开发的开源编程语言 遵循最新的 ES6、ES5规范 提供了类型校验 好处 为日后维护带来方便 增加代码可读性 提高安全性 安装1&gt; npm install -g typescript 编译1&gt; tsc &lt;file&gt; 配置生成 tsconfig.json1&gt; tsc --init 使用数据类型 TypeScript 中为了使编写的代码更规范，更利于维护，增加了类型校验 布尔值 boolean1let isDone: boolean = false; 数值 number 和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。 1234let decLiteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744; 字符串 string12let name: string = \"bob\";name = \"smith\"; 可以使用模板字符串数组类型 list「类型 + 方括号」来表示数组12// 数组中的所有元素都是同一类型let list: number[] = [1, 2, 3]; 使用数组Array Generic泛型表示12// 使用数组 泛型let list: Array&lt;number&gt; = [1, 2, 3]; 用接口表示数组1234interface NumberArray &#123; [index: number]: number; // 只要 index 的类型是 number ，那么 值得类型 必须是 number&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 类数组1234// 事实上常见的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等function sum() &#123; let args: IArguments = arguments;&#125; any 在数组中的应用1let list: any[] = [&#123;a:'b'&#125;, 25, 'a']; 枚举 enum enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。 用于取值被限定在一定范围内的场景，比如一周只能有七天 最好不要使用手动赋值 定义123enum 枚举名 &#123; 标识符[=整形常数]&#125; 12enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green; 编号 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号： 手动赋值后，未手动赋值的枚举项会接着上一个枚举项递增 如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 不会察觉到这一点 当手动赋值的枚举项不是数字时，需要使用类型断言来让tsc无视类型检查 手动赋值的枚举项也可以是小数或负数，此时未手动赋值的项递增步仍为112enum Color &#123;Red = 1, Green, Blue=&lt;any&gt;\"A\"&#125;let c: Color = Color.Green; 也可以全部都采取手动赋值 12enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green; 可以由枚举的值得到他的名字 1234enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2];console.log(colorName); // 显示'Green'因为上面代码里它的值是2 枚举项枚举项分为常数项（constant member）和计算所得项（computed member） 常数项 不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 1。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 0。 枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式： 数字字面量 引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用 带括号的常数枚举表达式 +, -, ~ 一元运算符应用于常数枚举表达式 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^ 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错 计算所得项 如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错：1234567891011121314enum Color &#123;Red, Green, Blue = \"blue\".length&#125; // '\"blue\".length 就是一个计算所得项。``` ##### 常数枚举 `const enum`常数枚举是使用 `const enum` 定义的枚举类型- 常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。```typescriptconst enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 编译结果1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 外部枚举 declare enum 外部枚举用来描述已经存在的枚举类型的形状。 declare 定义的类型只会用于编译时的检查，编译结果中会被删除。12345678declare enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 编译结果1var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 任意类型 any 为不清楚类型的变量指定一个类型123let notSure: any = 4;notSure = \"maybe a string instead\";notSure = false; // okay, definitely a boolean 空值 void 表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： 12345678// 方法没有返回值function warnUser(): void &#123; console.log(\"This is my warning message\");&#125;// 方法有返回值function Num(): number &#123; return 123&#125; 联合类型 Union Types 表示取值可为多种类型中的一种 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，只能访问此联合类型的所有类型里共有的属性或方法 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型123let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';myFavoriteNumber = 7; Null 和 Undefined 默认情况下 null 和 undefined 是所有类型的子类型。 指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自。1let num:number | null | undefined; 元组 Tuple 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。 元祖合并了不同类型的对象 数组合并了相同类型的对象 123456// Declare a tuple typelet x: [string, number];// Initialize itx = ['hello', 10]; // OK// Initialize it incorrectlyx = [10, 'hello']; // Error 访问 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 当访问一个越界的元素，会使用联合类型替代： 123x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toStringx[6] = true; // Error, 布尔不是(string | number)类型 Never never类型表示的是那些永不存在的值的类型 声明never的变量只能赋予never类型的值 Object object表示非原始类型 除number，string，boolean，symbol，null或undefined之外的类型 类型推论 TypeScirpt 在没有明确的指定类型的时候会推测出一个类型 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查12let myFavoriteNumber = 'seven';myFavoriteNumber = 7; // // index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 类型断言 手动指定一个值得类型 类型断言有两种形式1234567// 尖括号 语法let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length;// as 语法 =&gt; jsx 中 必须用这个let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 函数 函数是 JavaScript 中一等功民 声明 一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑在内 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。具名函数123function f():number &#123; return 123&#125; 匿名函数1234567let f = function():number &#123; return 123&#125;// 这段代码只对登号右侧的匿名函数进行了类型定义，等号左边的 f 是通过赋值操作进行类型推论而推断出来的，如果要对 f 添加类型，则：let f :(x:number,y:number) =&gt; number = function(x:number,y:number):number &#123; return x+y&#125; 用 接口 定义函数12345678interface F &#123; (x:number,y:number):number;&#125;let f:F;f=function(x:number,y:number):number &#123; return x+y&#125; 参数 函数调用时，输入多余或少于要求的参数，是不被允许的定义参数类型123function f(x:number,y:number):number &#123; return 123&#125; 可选参数? 可选参数必须写在最后123function f(x:number,y?:number):number &#123; return 123&#125; 默认参数123function f(x:number=20,y?:number):number &#123; return 123&#125; 剩余参数123function f(a:number,...rest:number[]):number &#123; return 213&#125; 函数重载 重载允许一个函数接收不同数量或类型的参数时，做出不同的处理123456789function f(name:string):stringfunction f(age:number):numberfunction f(str:any) &#123; if (typeof str === 'string')&#123; return `str$&#123;str&#125;` &#125; else &#123; return `str$&#123;str&#125;` &#125;&#125; 类 传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承 ES6中 class 实现类的概念 类（Class）：定义一个事物的抽象特点，包涵他的属性和方法 对象（Object）：类的实例。通过new实现 面向对象（OOP）的三大特性：封装、继承、多态 封装（Encapsulation）：将数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如：Cat和Dog都继承自Animal，但是分别实现了自己的eat方法。此时针对某一实例，我们无需了解它是Cat还是Dog，就可以直接调用eat方法，程序会自动判断出应如何执行eat 存取器（getter&amp;setter）：用以改变属性的读取和赋值行为 修饰符（Modified）：修饰符是一些关键字，用于限定成员或类型的性质，比如public表示公有属性或方法 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中实现 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口 定义类 class：定义类 constructor：定义构造函数123456789class Person &#123; name:string; // 属性 省略了 public 关键词 constructor(name:string)&#123; // 构造函数 实例化类时触发的方法 this.name = name &#125; run():void&#123; console.log(this.name); &#125; &#125; 继承 extend：实现继承 super：调用父类的构造函数和方法12345class Web extends Person&#123; constructor(name:string)&#123; super(name) &#125;&#125; 存取器使用 getter 和 setter 可以改变属性的赋值和读取行为：1234567891011class Animal &#123; constructor(name:string)&#123; this.name=name; &#125; get name()&#123; return 'a' &#125; set name(value)&#123; console.log('setter'+value); &#125;&#125; 修饰符属性不加修饰符默认是公有属性 公有修饰符 public public 修饰的属性或方法都是公有的，可以在任何地方被访问到 保护类型 protected protected 修饰的属性或方法是受保护的，它和private类似，区别是他在子类中也是被允许访问的 在当前类里、子类里可以访问 私有类型 private private修饰的属性或方法是私有的，不能在声明他的类的外部访问 只有在当前类里可以访问 只读属性 readonly静态类型 static 静态方法：使用static修饰的方法称为静态方法，他们不需要实例化，而是直接通过类来调用 静态属性：使用static修饰的属性称为静态属性，他们不需要实例化，而是直接通过类来调用12345678910111213class Animal &#123; constructor(name:string)&#123; this.name=name &#125; static isAnimal(a)&#123; return a instanceof Animal; &#125;&#125;let a = new Animal('a');Animal.isAnimal(a); //truea.(aisAnimal); // TypeError: a.isAnimal is not a function 多态父类定义一个方法不去实现，让继承他的子类去实现，每一个类有不同的表现1234567891011121314151617class Animal &#123; name:string; constructor(name:string)&#123; this.name=name &#125; eat():void&#123; console.log(this.name); &#125; &#125;class Dog extends Animal &#123; constructor(name:string)&#123; super(name) &#125; eat(name:string):void&#123; console.log(`$&#123;name&#125;吃`); &#125;&#125; 抽象类提供其他类继承的基类，不能直接被实例化 定义abstract定义抽象类和抽象方法 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现 12345678910111213141516171819202122abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;let a = new Animal('Jack'); // index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'.class Cat extends Animal &#123; sayHi()&#123; console.log(`$&#123;this.name&#125; say hi.`); &#125; public eat() &#123; console.log(`$&#123;this.name&#125; is eating.`); &#125;&#125;let cat = new Cat('Tom');// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'. 抽象方法只能放在抽象类里 抽象类的派生类必须必须实现抽象类里的抽象方法123456abstract class Animal &#123; abstract makeSound(): void; move(): void &#123; console.log('roaming the earch...'); &#125;&#125; 接口 InterfacesTypeScript 中，使用 接口 来定义对象的类型 作用 在面向对象的编程中，接口是一种规范的定义，他定义了行为和动作的规范，在程序设计里，接口起到了限制和规范的作用。 接口定义了某一批类所需遵守的规范，接口不关心这些类的内部状态数据，也不关心这些类里方法的实现细节，他只规定这批类里必须提供默写方法，提供这些方法的类就可以满足实际需求。 分类普通接口定义1234interface FullName &#123; firstName:string, secondName:string,&#125; 使用 赋值的时候，变量的形状和接口的形状必须保持一致不可以多，不可以少123456789interface FullName &#123; firstName:string, secondName:string,&#125;let name:FullName= &#123; firstName:'a', secondName:'bc',&#125; 函数类接口(混合类型) 使用接口定义一个函数需要符合的类型 123456interface Config &#123; (value:string):string;&#125;let setData:Config=function(value:string):string &#123; return ''&#125; 当函数有自己的属性和方法 1234567891011121314151617interface Counter &#123; (start:number):string; interval:number; reset():void;&#125;function getCounter():Counter &#123; let counter = &lt;Counter&gt;function(start:number) &#123;&#125; counter.interval=123; counter.reset=function() &#123;&#125; return counter&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 可索引接口对数值、对象的约束1234interface UserArr&#123; [index:number]:number&#125;let arr:UserArr=[123,13] 1234interface UserObj &#123; [index:string]:string&#125;let user:UserObj=&#123;w:'qw'&#125; 类类型接口 实现implements是面向对象的一个重要概念。 一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候可以把特性提取成接口interfaces，用implements关键字来实现，这个特性大大提高了面向对象的灵活性 举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它： 123456789101112131415161718interface Alarm &#123; alert();&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert() &#123; console.log('SecurityDoor alert'); &#125;&#125;class Car implements Alarm &#123; alert() &#123; console.log('Car alert'); &#125;&#125; 一个类也可以实现多个接口 1234567891011121314151617181920interface Alarm &#123; alert();&#125;interface Light &#123; lightOn(); lightOff();&#125;class Car implements Alarm, Light &#123; alert() &#123; console.log('Car alert'); &#125; lightOn() &#123; console.log('Car light on'); &#125; lightOff() &#123; console.log('Car light off'); &#125;&#125; 上例中，Car 实现了 Alarm 和 Light 接口，既能报警，也能开关车灯。 接口扩展12345678910interface A &#123; a():void;&#125;interface B extends A&#123; b():void;&#125;class C implements B&#123; a():void &#123;&#125; b():void &#123;&#125;&#125; 可选属性 可选属性的含义是 该属性 可以不存在，但是 仍然不允许添加未定义的属性 当不需要完全匹配一个形状时，可以用可选属性1234567891011121314interface Person &#123; name:string, age?:number&#125;let ton:Person = &#123; name:'Tom'&#125;// 添加 未定义属性 报错let jone:Person = &#123; name: 'Tom', age: 25, gender: 'male'&#125; 任意属性 希望一个接口允许有任意的属性 12345678910interface Person &#123; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: 'Tom', gender: 'male'&#125;; 一旦定义任意属性，那么确定属性 和可选属性的类型都必须是他的类型的子集 123456789101112131415161718192021interface Person &#123; name: string; age?: number; [propName: string]: string;&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male'&#125;;// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.// index.ts(7,5): error TS2322: Type '&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.// Index signatures are incompatible.// Type 'string | number' is not assignable to type 'string'.// Type 'number' is not assignable to type 'string'.//上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。//另外，在报错信息中可以看出，此时 &#123; name: 'Tom', age: 25, gender: 'male' &#125; 的类型被推断成了 &#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;，这是联合类型和接口的结合。 只读属性 readonly当希望对象中的一些字段只能在创建的时候被赋值，可以用只读属性1234567891011121314interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; id: 89757, name: 'Tom', gender: 'male'&#125;;tom.id = 9527; // 报错 泛型 Generics 泛型是指在定义函数、接口或类的时候，不预先指定具体类型，而在使用的时候在指定类型的一种特性 软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。 无法创建 泛型枚举 和 泛型命名空间定义123function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; 我们给identity添加了类型变量T。T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。之后我们再次使用了T当做返回值类型。现在我们可以知道参数与返回值类型是相同的。这允许我们跟踪函数里使用的类型的信息 使用 传入所有的参数，包括类型参数1let output = identity&lt;string&gt;('myString'); // type of output will be 'string' 这里我们明确的指定了T是 string类型，并做为一个参数传递给了函数 利用类型推论 – 编译器会根据传入的参数自动地帮助我们确定T的类型1let output = identity('myString'); // type of output will be 'string' 这里并没有明确的使用&lt;&gt; 来明确地传入类型；编译器可以查看myString的值，然后把T设置为他的类型。类型推论帮助我们保持代码精简和可读性。 泛型类型 泛型函数的类型 与 非泛型函数的类型 没什么不同，只是有一个类型参数在最前面，想函数声明一样 12345function identity&lt;T&gt;(arg:T):T &#123; return arg;&#125;let myIdentity:&lt;T&gt;(arg:T)=&gt;T=identity; 也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以 12345function identity&lt;T&gt;(arg:T) &#123; return arg;&#125;let myIdentity: &lt;U&gt;(arg:U)=&gt;U=identity; 还可以使用带有调用签名的对象字面量来定义泛型函数 12345function identity&lt;T&gt;(arg:T):T &#123; return arg;&#125;let myIdentity:&#123;&lt;T&gt;(arg:T):T&#125;=identity; 把上面例子里的对象字面量拿出来作为一个接口 123456789interface GenericIdentityFn &#123; &lt;T&gt;(arg:T):T;&#125;function identity&lt;T&gt;(arg:T):T &#123; return arg;&#125;let myIdntity:GenericIdentityFn=identity; 我们可以把泛型参数当作整个接口的一个参数。这样我们就能清楚的知道使用的具体是哪个泛型类型 123456789interface GenericIdentityFn&lt;T&gt; &#123; (arg:T):T;&#125;function identity&lt;T&gt;(arg:T):T &#123; return arg;&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity; 泛型类12345678910111213141516class Min&lt;T&gt;&#123; public list:T[]=[] add(value:T):void&#123; this.list.push(value) &#125; min():T&#123; let min = this.list[0]; this.list.forEach(item =&gt; &#123; if (min &gt; item)&#123; min = item; &#125; &#125;) return min &#125;&#125;const m = new Min&lt;number&gt;() 泛型接口12345678910interface Config&lt;T&gt; &#123; &lt;T&gt;(value:T):T;&#125;function f&lt;T&gt;(value:T):T &#123; return value&#125;let a = f&lt;number&gt;(1);let b:Config&lt;number&gt; = fb(2) 声明文件 当使用第三方库时，需要引用他的声明文件，才能获得对应的代码补全，接口提示功能 通常会吧 声明语句 放到一个单独的文件 （*.d.ts）中 声明文件 必须以 .d.ts 结尾 声明语句 declare var declare var 没有定义一个变量，只是定义了全局变量的类型12declare var jQuert:(selector:string)=&gt;anyjQuert('#foo') 第三方声明文件搜索地址 书写声明文件在不同场景下，声明文件的内容和使用方式有所区别 全局变量：通过 script 标签引入的第三方库，注入全局变量 npm包：通过 import foo from ‘foo’ 导入，符合 ES6模块规范 UMD库：即可以通过 script 标签引入，也可以通过 ES6 模块规范 模块插件：通过 import 导入后，可以改变另一模块的结构 直接扩展全局变量：通过 script 引入后， 改变一个全局变量的结构。比如 ：为 Array.prototype 新增一个方法 通过导入扩展全局变量：通过 import 导入后，可以改变一个全局变量的结构 内置对象JavaScript 中的很多内置对象,可以直接在 TypeScript 中当做定义好了的类型 ECMAScript 的内置对象1234let b: Boolean = new Boolean(1);let e: Error = new Error('Error occurred');let d: Date = new Date();let r: RegExp = /[a-z]/; DOM 和 BOM 的 内置对象Document、HTMLElement、Event、NodeList 等12345let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll('div');document.addEventListener('click', function(e: MouseEvent) &#123; // Do something&#125;); TypeScript 核心库的定义文件 TypeScript 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。 当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了 用 TypeScript 写 Node.jsNode.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：1&gt; npm install @types/node --save-dev 类型别名 type 给一个类型取一个新名字 类型别名适用于 联合类型12345678910type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n:NameOrResolver) &#123; if (typeof n === 'string')&#123; return n; &#125; else &#123; return n(); &#125;&#125; 字符串字面量类型 约束取值只能是某几个字符串中的一个1234type EventNames = 'click'| 'scroll'|'mouseOver'function handleEvent(ele:Element,event:EventNames) &#123; // do sth&#125; 声明合并参考文章 TypeScript 入门教程 TypeScript Handbook（中文版）","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.bevexed.top/categories/TypeScript/"}],"tags":[]}]}