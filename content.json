{"meta":{"title":"两万","subtitle":"Daily","description":"前端日常学习","author":"两万","url":"http://blog.bevexed.top"},"pages":[{"title":"简历","date":"2019-01-22T08:40:05.000Z","updated":"2020-01-07T05:47:26.238Z","comments":true,"path":"about/index.html","permalink":"http://blog.bevexed.top/about/index.html","excerpt":"","text":"个人信息 姓名：李春玉 电话：18640460506 微信：18640450506 邮箱：547551650@qq.com blog：https://blog.bevexed.top/about/ github：https://github.com/bevexed 求职意向 期望地区：杭州 期望薪资：12k - 15k （要有5险1金） 目前状况：在职，一个月内可上岗 期望工作性质：全职 教育经历 学历：本科 院校：沈阳理工大学 职业技能 熟练使用 JavaScript、ES6、HTML5，了解 Nodejs、jQuery、TypeScript 熟练使用 CSS3、Sass、Less，精通 flex 布局 熟练使用 React、Vue 全家桶 熟练使用 Photoshop、Ilustrator 等设计软件 熟练使用 elementUI、mui、Ant Design、NG-ZORRO、layUI、iView 等 UI 库 能够进行 原生小程序（微信、支付宝）的开发，同时也可以 使用 mpvue、uni-app 等第三方框架进行小程序的开发 能够使用 canvas 进行 h5 活动页面的原生开发 熟练使用 Echart、高德地图、腾讯地图 等第三方图形库 熟练使用 webpack、gulp 等打包工具 熟练使用 npm、yarn、bower 等包管理工具 能使用 git 的基础命令管理代码 能使用简单的 命令行 操作系统 自我评价 有较强的自学能力和独立解决问题的能力 对环境的适应速度快，能够迅速融入团队,性格开朗，有耐心 擅长沟通，非常热爱互联网行业，对工作由非常大的激情 工作经历天跃科技（2018.10 – 现在） 职位：web前端 项目（倒序） 狗鱼（h5） 中坚（h5） 方体语文二期（小程序） 方体语文（小程序、IOS、Andriod） 绝味鸭脖（微信小程序、支付宝小程序） 迷纯（小程序） 一起秀（小程序、h5） 星医馆（h5） 职场思南（PC，h5，后端管理系统） 一品数码会（小程序） 5进一 （后端管理系统） POS商城（h5，安卓） 电竞资讯（h5） 对宇婚恋（h5） 至惠云商（h5、小程序） 创铭景利网络科技公司（2018.05 – 2018.10） 职位：web前端 项目： 袋鼠金服（PC端） 滴滴视频（PC端） 真美好（h5） 沈阳东深公司 (2017.12 – 2018.05) 职位: UI设计、web前端 项目： 狮兔同购（微信H5） 宁夏理工官网（PC端） 第二课堂（PC端） 项目经验狗鱼（h5） 项目技术栈： 前段页面展示：React 全家桶、TypeScript、scss 前后台数据交互：使用 Promise 对 axios 接口二次封装 构建工具：webpack 项目描述：仿 keep 的电商app 责任描述： 搭建项目页面 和后台交换数据 和 IOS 和 Andriod 进行数据交互 项目收获： 对 TypeScript 的泛型以及其他知识有了新的理解 对 组件化 和 模块化 有了新的认识 对 css3 的动画有了更深的需求 方豆豆语文二期（微信小程序） 项目技术栈： 前段页面展示：wxml、wxss、js 前后台数据交互：使用 Promise 对 request 接口二次封装 构建工具：微信开发者工具 项目描述：教师端小程序，用于批改学生上传的作业 责任描述： 搭建项目页面 和后台交换数据 实现教室批改作业并且录音的需求 实现教师端（微信小程序）、学生端（微信小程序、IOS、Andriod、h5）教师批改作业过程的复现，并且实现一个可拖拽的进度条来控制播放进度 项目收获： canvas 的移动端适配，可以在不同大小的屏幕上展示同样的效果 对 音频 和 canvas 的控制更加熟练 对 各端的兼容更加熟练 方体语文(微信小程序、IOS、Andriod、h5 分享页) 项目技术栈： 前端页面展示：uni-app、vue、vuex、js、scss、html 前后台数据交互：使用 Promise 对 request 接口二次封装 构建工具：HbuilderX 项目描述：专注儿童教育的app 责任描述： 搭建项目页面 和后台交换数据 app上架 解决适配问题 项目收获： 整个项目的 动画、音频、视频 比较多，并且需要控制顺序，锻炼了写回调函数的能力 需要预防一些特殊情况（如app退到后台）的发生，锻炼了逻辑，使逻辑更加缜密 第一次发布 App，对 App 的发布流程有了一定的了解 绝味鸭脖(微信小程序、支付宝小程序) 项目技术栈： 前端页面展示：js、css、axml（支付宝）、wxml（微信） 前后台数据交互：使用 Promise 对 request 接口二次封装 构建工具：微信开发者工具、小程序开发者工具 项目描述：绝味鸭脖线上小程序 责任描述： 搭建项目页面 和后台交换数据 微信和支付宝的授权、付款的接入 项目收获： 能写支付宝的原生小程序了 某些特定的接口不会出现在文档里，需要商务和微信或支付宝去买 富海（后台管理系统） 项目技术栈： 前端页面展示：React、js、less、Ant Design、html、dva 前后台数据交互：axios 构建工具：webpack 项目描述：富海加油站 H5 的后台管理页面面 责任描述 使用 react 、Ant Design 开发页面 使用 dva 管理数据 项目收获： 了解了 dva 富海(h5抽奖) 项目技术栈： 前端页面展示：React、js、scss、html 前后端数据交互：axios 构建工具：webpack 项目描述：富海加油站 H5 抽奖页面 责任描述： 使用 react 框架开发页面 使用 axios 与后台交互 微信授权登录 项目收获： 使用 css3 动画替代 js 动画，对 css 动画产生了兴趣 迷唇（小程序） 项目技术栈： 前端页面展示：uni-app、vue、vuex、typescript、scss、html、uchart 前后端数据交互：对 uni-request 进行二次封装 构建工具：webpack 项目描述：电子烟电商项目 责任描述： 使用 Vue 的模板以及小程序的原生组件 进行静态页面的开发 使用封装好的 ajax 与后台进行数据对接 实现微信小程序的自动登录 项目收获： 用 scss 封装了 upx 函数、全局变量以及使用较多的样式类，同时使用 webpack 构建项目，并且封装了大量组件 学会了新的图表库 u-chart 对 typeScript 的使用更加熟练 一起秀（小程序、h5） 项目技术栈 前端页面展示：uni-app、vue、vuex、js、scss、html 前后台数据交互：使用 promise 对 wx.request 进行二次封装 构建工具：Hbuilder 项目描述：一个具有AI识别布料，在线试穿等功能的电商项目 责任描述： 使用 Vue 的模板以及小程序的原生组件 进行静态页面的开发 对 wx.request 接口进行二次封装，方便后期与后台进行数据进行交换 对路由进行二次封装，方便后期鉴权、页面跳转等操作 因为是电商项目，所以数据比较多，所以使用 Vuex 来管理数据。一是方便组件之间的数据通信，二是使用单向数据流的方式进行数据的中心化管理，让整个 app 的逻辑相对清晰 项目收获： 通过使用 uni-app，在使用的过程中学会了新框架 整个框架借鉴 Vue ，使得对 Vue 的使用更加熟练 在开发的过程中又遇到了新 bug，积攒了新的经验，比如 原生组件的覆盖问题 对微信小程序有了更加全面的认识 项目使用了 Vuex 的模块化管理数据，使得对 Vuex 的操作更加熟练 通过 css3 结合原生 js 实现 双指操作下的图片放大、缩小，移动等操作，对多指操作有了新的理解 星医馆 技术栈： 前端页面展示： react、react-router、react-router-dom、redux、react-redux、redux-thunk、ant-mobile、rc-queue-anim、qrcode.react、scss、echart 前后台数据交互：对 axios 进行二次封装、js-cookie、easemob-websdk 构建工具：webpack 项目描述：一个将医患关系从线下转换为线上的聊天APP。 责任描述： 使用 react 全家桶，快速的进行静态页面的开发 按需将路由抽离为 公共路由、医生路由、助手路由、病人路由 四部分，然后根据实际情况分配相应的路由权限 提取并封装公共组件，加速项目的开发速度 使用 redux 对数据进行管理，因为整个项目涉及 好友管理、聊天数据管理、发朋友圈、朋友圈预览、选择推荐分组等功能，所以此处使用 redux 有利于对缓存数据进行管理 使用 easemob-websdk（环信）接入聊天系统，通过调用相应的 api 实现文字、语音、图片、视频的实时转发 使用 wxjssdk 实现微信支付、微信分享、图片预览等功能 使用 echart 的饼状图以及折线图来统计医生的收入，以及添加患者等数据 项目收获： 第一次用 react 开发，体验极好 通过对 redux 的学习，对 Vuex、Flux、Redux-saga、Dva、Mobx 也有更深入的理解 前端处理了非常多的数据，js 能力有所提升 使用了 ant-mobile，学习了新的UI库 通过路由的按需分配，对鉴权业务烂熟于心 职场思南（PC、H5、后台管理系统） 技术栈： 前端页面展示：Angular 全家桶、iview、typeScript 前后台数据交互：Rxjs、httpClient 构建工具：webpack 项目描述：一个关于高考报考视频网站的二次开发（修改bug）项目 责任描述： 根据现有设计图，对页面进行修改、添加 为修改以及添加的页面，进行接口的对接 修改遗留bug 接通微信支付 实现 PC 端的自适应 解决 H5 端的弹窗问题 解决 H5 端的返回键退出app问题 解决页面第一次加载超过一分钟的问题 解决后台上传图片，图片在前台显示不清晰的问题 写后台管理界面，以及相应的接口 修改所有页面的主题颜色 项目收获： 对 Angular 有了一定的了解，但是深度有限，只是能进行普通开发和调试 对代码规范有了更加全面的体会 对模块化有了更深入的理解 解决图片清晰度的问题时，对图片的压缩有了新的想法 学会使用了 NG-ZORRO UI 库 实现了 微信支付 的非H5 调用 对 ts 的使用更加熟练 一品数码会（小程序） 技术栈： 前端页面展示：微信原生小程序，typeScript、iview 前后台数据交互：wx.request 构建工具：微信开发者工具 项目描述：二手手机回首转售平台 责任描述： 使用微信原生组件搭建页面 与后台对接数据 实现自动登录 项目收获： 第一次原生开发小程序 发现了大量微信原生 UI 库 开发的过程中又读了几遍文档，发现了新功能 5进一（h5，后台管理系统） 技术栈： 前端页面展示：Vue全家桶，elementUI 前后台数据交互：axios 构建工具：webpack 项目描述：一个微商后台管理系统 责任描述： 鉴权路由 数据的表格展示，以及操作 落地页及其接口 项目收获： 第一次开发后台管理系统，对后台管理系统有了更加全面的认识 由于路由是可以配置的，所以路由数据由后台返回，然后前端动态生成相应路由，使我对鉴权路由有了更深的理解 项目用到了比较多的字典，体会到了配置文件的好 POS商城（h5、打包安卓APP） 技术栈： 前端页面展示：Vue全家桶、ydUI、swiper、elementUI、mui 前后台数据交互：axios 构建工具：webpack、hbuilder 项目描述：POS机销售商城 责任描述： 使用各种 UI 库，快速开发页面 与后台进行数据的对接 项目收获： 第一次用 h5 打包 app 至惠云商（h5、小程序） 技术栈： 前端页面展示：Vue全家桶、elementUI 前后台交互：axios 构建工具：webpack 项目描述：乡村电商项目 责任描述： 对已有页面进行转换 修复遗留 bug 兼容安卓h5，安卓、iosH5、ios、微信小程序的支付、注册、登录问题 解决一期、二期页面互相跳转时的授权问题 解决各端地图接入时的授权问题 解决遗留闪屏问题 解决各端的分享问题 协助后台解决遗留问题 项目收获： 后端没有开发环境，所有代码需要本地上传服务器才能看出效果，练就了默写代码，凭空猜测 bug 的本事 阅读前人小程序端支付的代码，学到了如何通过在小程序内通过 h5 调取小程序的原生支付 对用户自动登录有了全面深入的思考 踩遍了 vue 在微信 H5 中的分享、支付由于路径问题带来的所有坑 对路由的数据缓存有了新的认识 熟练的使用 vconsole 调试移动端代码 对各端的兼容，有了更深入的理解 对 wxjssdk 的调用更加熟练 袋鼠金服（PC） 技术栈： 前端页面展示：Vue全家桶、elementUI、swiper 前后台交互：axios 构建工具：webpack 项目描述：P2P项目 责任描述： 使用 Vue 开发页面，echart 等图型库进行数据展示 使用 axios 与后台进行数据交互 项目收获 第一次使用 vue 进行单页面开发 理解 路由 的概念 第一次独立进行开发 很多问题需要自己去深入的思考 通过对 axios 的再次封装来管理用户登录状态，对 ajax 有了新理解 滴滴视频（PC） 技术栈： 前端页面展示：Vue全家桶 前后台交互：axios 构建工具：webpack 项目描述：在线视频网站 责任描述： 前期封装基础组件，后期通过对组件的拼装进行快速开发 根据用户等级，动态的展示相应的页面 项目收获： 对 m3u8 的流媒体视频加载有了一定的了解 更加熟练的使用 Vue 狮兔同购（H5） 技术栈： 前端页面展示：Vuejs、swiper、jQuery、HTML5、CSS3 前后台交互：jQuery 中的 ajax photoShop 项目描述：在线直播电商项目 责任描述： 前期根据产品和客户的需求设计 UI界面 使用 Vuejs、jQuery 开发多页面 项目收获： 第一次接触 mvc 框架 有了新的开发体验 学习了 ES6 对视频开发有了新的理解 宁夏理工官网（PC） 技术栈： 前端页面展示：HTML5、CSS3、swiper、jQuery 前后台交互：jQuery 中的 ajax photoShop 项目描述：大学官网 责任描述： 前期根据产品和客户的需求设计 UI界面 使用 jQuery 开发多页面 项目收获： 对 h5 和 css3 的使用更加熟练 对 jQuery 中的常用 api 掌握的更好 第二课堂（PC） 技术栈： 前端页面展示：HTML5、CSS3、swiper、jQuery、Vue、Angular、Echart、layUI、Bootstrap 前后台交互：jQuery 中的 ajax 项目描述：管理大学生业余时间的项目 项目收获： 项目的 css 动画特别多，加深了我对 css 的理解 项目需要兼容 ie、360、火狐、谷歌 等浏览器，在兼容方面了一定的提升"},{"title":"home","date":"2019-01-22T10:45:49.000Z","updated":"2019-01-22T10:46:13.548Z","comments":true,"path":"home/index.html","permalink":"http://blog.bevexed.top/home/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-01-22T08:40:41.000Z","updated":"2019-01-22T08:40:41.491Z","comments":true,"path":"archives/index.html","permalink":"http://blog.bevexed.top/archives/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-01-21T09:21:34.000Z","updated":"2019-01-22T10:43:17.071Z","comments":true,"path":"categories/index.html","permalink":"http://blog.bevexed.top/categories/index.html","excerpt":"","text":""},{"title":"mongodb","date":"2020-01-26T05:55:48.000Z","updated":"2020-01-26T05:55:48.999Z","comments":true,"path":"mongodb/index-1.html","permalink":"http://blog.bevexed.top/mongodb/index-1.html","excerpt":"","text":""},{"title":"mongodb","date":"2020-01-26T05:55:27.000Z","updated":"2020-01-26T05:55:27.824Z","comments":true,"path":"mongodb/index.html","permalink":"http://blog.bevexed.top/mongodb/index.html","excerpt":"","text":""},{"title":"sitemap","date":"2019-01-22T08:42:09.000Z","updated":"2019-01-22T08:42:09.109Z","comments":true,"path":"sitemap/index.html","permalink":"http://blog.bevexed.top/sitemap/index.html","excerpt":"","text":""},{"title":"sitemap","date":"2019-02-11T06:25:21.000Z","updated":"2019-02-11T06:25:21.938Z","comments":true,"path":"sitemap/index-1.html","permalink":"http://blog.bevexed.top/sitemap/index-1.html","excerpt":"","text":""},{"title":"schedule","date":"2019-01-22T08:41:04.000Z","updated":"2019-01-29T10:08:24.225Z","comments":true,"path":"schedule/index.html","permalink":"http://blog.bevexed.top/schedule/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-01-22T08:40:15.000Z","updated":"2019-01-22T08:52:30.489Z","comments":true,"path":"tags/index.html","permalink":"http://blog.bevexed.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"mongodb","slug":"mongodb","date":"2020-01-26T05:55:15.000Z","updated":"2020-01-26T07:24:24.744Z","comments":true,"path":"2020/01/26/mongodb/","link":"","permalink":"http://blog.bevexed.top/2020/01/26/mongodb/","excerpt":"","text":"mongoDBmongoDB 是文档数据库，存储的是文档 Bson（ json 的二进制化） 特点：内部执行引擎为 JavaScript 解释器，把文档存储成 bson 结构，在查询时转换为 JS 对象，并通过 js 语法来操作 和传统数据库的不同点： 传统数据库： 结构化数据库：定好了表结构后，每一行内容必须是符合结构的 mongoDB： 文档型数据库：表下的每篇文档都可以有自己独特的结构 安装请参考 https://www.mongodb.org.cn/ 安装后的命令核心 mongod：数据库核心进程（服务端） mongos：查询路由器，集群时使用 mongo：交互终端（客户端） 数据导入导出 mongoexport：导出容易是别的 json、csv、tsv 格式 mongoimport：导入 json、csv、tsv 二进制导入导出 mongodump：导出 bson 数据 mongorestore：导入 bson bsondump：bson 转换为 json 诊断工具 mongostat mongotop mongosniff：检测 mongo 运行状态 简单使用启动： mongod –dbpath path –logpath path –prot prot –fork 参数： dbpath：数据存储目录 logpath：日志存储目录 port：运行端口（默认27017） fork：以后台运行 smallfiles：占用小空间启动 基本入门命令 show dbs ：查看当前数据库 use dataBasename：使用数据库 show collections：查看 collection","categories":[{"name":"数据库","slug":"数据库","permalink":"http://blog.bevexed.top/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://blog.bevexed.top/tags/数据库/"},{"name":"mongodb","slug":"mongodb","permalink":"http://blog.bevexed.top/tags/mongodb/"}]},{"title":"Nginx入门指南","slug":"nginx入门指南","date":"2019-09-06T05:52:09.000Z","updated":"2019-09-10T06:09:19.085Z","comments":true,"path":"2019/09/06/nginx入门指南/","link":"","permalink":"http://blog.bevexed.top/2019/09/06/nginx入门指南/","excerpt":"","text":"简述 Nginx nginx有一个主进程和几个工作进程。(参看 worker_processes). 主进程的主要目的是为了读取和评估配置并且维护工作进程。工作进程处理实际请求。 nginx在工作进程中采用事件驱动模型和OS依赖机制有效分配请求。 工作进程的数量取决于配置文件中定义的固定值或者是通过有效的CPU核数自动判定数量。 工作进程的数量在配置文件中定义，可据给定的配置对工作进程的数量进行固定，也可以根据可用CPU内核的数量进行自动调整。 nginx及其各模块的工作方式取决于配置文件。 默认情况下，配置文件名为nginx.conf，并放置在/usr/local/nginx/conf、/etc/nginx或/usr/local/etc/nginx.目录中。 安装 自行参考 Installing nginx 页面1&gt; brew install ngnix 启动, 停止, 和重新加载配置文件 启动的时候直接运行nginx.exe或者nginx。如果nginx已经启动，就可以直接使用参数-s 来进行调用执行，具体的使用语法如下： 1&gt; nginx -s signal signal 的位置可以是如下参数： stop — 指令一经发出，直接停止 quit — 等待所有的请求完成，再停止 reload — 重新加载配置文件nginx.conf reopen — 重新打开日志文件 配置文件结构 nginx由模块组成 这些模块由配置文件中指定的指令控制。 指令分为简单指令和块指令。 一个简单的指令由名称和参数组成，这些名称和参数由空格分隔，并以分号(;)结尾。 块指令具有与简单指令相同的结构，但它的结尾不是分号，而是一组由大括号({、})包围的附加指令。 如果一个块指令在大括号中包含其他指令，则这个块指令又叫做上下文 (例如: events, http, server, 和location). 放在任何上下文之外的配置文件中的指令被认为是在主上下文中。 event 和 http 指令驻留在主上下文中，server 驻留在 http 中，location 驻留在 server中。 一行中在#符号后面的是注释 全局块 从配置文件开始到 events 块之间的内容 主要设置影响 Ngnix 服务器整体运行的配置指令 event 块 涉及的指令主要影响 Nginx 服务器与用户的网络连接 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置 http 块 是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里 http 块中也可以包括 http 全局块、 server块 http 全局块 http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。 sever 块 这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。后面会详细介绍虚拟主机的概念。 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。 location 块 一个 server 块可以配置多个 location 块。 这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 功能 web服务器最重要的任务是对外提供文件，例如(图片或者静态HTML网页)。 提供静态资源内容 通常，配置文件包含几个server块指令，这些块指令通过不同的服务名字（server names）分发监听（distinguished listen）在不同的端口。 一旦nginx决定哪个服务器处理请求，它就会根据 server 块指令中定义的 location 指令的参数匹配请求头中指定的URI。 在server块指令中添加 location 指令：1234location / &#123; root /data/www;&#125;` 这个location块详述了与URI请求相匹配的“/”前缀。如果匹配到请求，这个 URI 会被转到 root 指令的路径。也就是说，所有请求文件都会直接请求到本地文件系统的/data/www路径。如果有多个匹配的location块，nginx会选择最长前缀的那个。上面提供的location块是长度只有1的最短前缀，因此，其它所有的location块都匹配失败的话，这个location块指令才会被使用。 添加第二个location块：123location /images &#123; root /data;&#125; 这个会匹配以/images开头的请求（/也会匹配请求，只不过这个前缀更短）。 一个正常的服务器配置文件监听在80端口上，并且可以在本机上成功访问http://localhost/。 以/images/开头请求的URI地址，服务器会从/data/images文件夹下面返回对应的文件。例如，请求/data/images/example.png这个文件，nginx服务器会返回http://localhost/images/example.png。 如果服务器没有这个文件会返回404 错误。不是以/images/开头的请求,就会被映射到/data/www 文件夹。例如, 请求nginx/data/www/some/example.html,服务器会响应http://localhost/some/example.html 这个文件。 为了应用一个新的配置文件，如果nginx还没有启动，就直接启动nginx服务器，如果已经启动，直接使用下面指令发送到nginx的主进程中，如下: 如果nginx尚未启动，则启动nginx，或者向nginx的主进程发送重新加载信号，执行: 1&gt; nginx -s reload 反向代理 正向代理代理客户端，反向代理代理服务器 反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。 反向代理配置 例：使用 Ngwmeinx 反向代理 localhost:8000 直接跳转到 http://localhost:3000 12345678910server &#123; listen 8000; #listen somename:8080; server_name somename alias another.alias; location / &#123; proxy_pass http://localhost:3000; index index.html index.htm; &#125; &#125; listen配置网络监听，主要语法结构有三种 配置监听的IP地址 1listen address[:port] [default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [deferred] [accept_filter=filter] [bind] [ssl]; 配置监听端口 1listen port[default_server] [setfib=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [ssl]; 配置 UNIX Domain Socket 1listen unix:path [default_server] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ssl]; 实例 1234listen *:80 | *:8080 #监听所有80端口和8080端口listen IP_address:port #监听指定的地址和端口号listen IP_address #监听指定ip地址所有端口listen port #监听该端口的所有IP连接 下面分别解释每个选项的具体含义： address : IP地址，如果是 IPV6地址，需要使用中括号[] 括起来，比如[fe80::1]等。address : IP地址，如果是 IPV6地址，需要使用中括号[] 括起来，比如[fe80::1]等。port : 端口号，如果只定义了IP地址，没有定义端口号，那么就使用80端口。path : socket文件路径，如 var/run/nginx.sock等。default_server : 标识符，将此虚拟主机设置为 address:port 的默认主机。（在 nginx-0.8.21 之前使用的是 default 指令）setfib = number : Nginx-0.8.44 中使用这个变量监听 socket 关联路由表，目前只对 FreeBSD 起作用，不常用。backlog = number : 设置监听函数listen()最多允许多少网络连接同时处于挂起状态，在 FreeBSD 中默认为 -1,其他平台默认为511.rcvbuf = size : 设置监听socket接收缓存区大小。sndbuf = size : 设置监听socket发送缓存区大小。deferred : 标识符，将accept()设置为Deferred模式。accept_filter = filter : 设置监听端口对所有请求进行过滤，被过滤的内容不能被接收和处理，本指令只在 FreeBSD 和 NetBSD 5.0+ 平台下有效。filter 可以设置为 dataready 或 httpready 。bind : 标识符，使用独立的bind() 处理此address:port，一般情况下，对于端口相同而IP地址不同的多个连接，Nginx 服务器将只使用一个监听指令，并使用 bind() 处理端口相同的所有连接。ssl : 标识符，设置会话连接使用 SSL模式进行，此标识符和Nginx服务器提供的 HTTPS 服务有关。 server_name 用于虚拟主机的配置，通常两种配置方法： 1server_name name...; 对于 name 来说，可以只有一个名称，也可以有多个名称，中间用空格隔开。而每个名字由两段或者三段组成，每段之间用 . 隔开 1server_name baidu.com www.baidu.com 可以使用通配符 *，但通配符只能用在由 三段字符 诸城的首段或者尾端 1server_name baidu.com www.baidu.com 可以使用正则表达式，用“~”作为正则表达式字符串的开始标记 1server_name ~^www\\d+\\.123\\.com$; 匹配优先级 12341. 准确匹配 server_name2. 通配符在开始时匹配 server_name 成功3. 通配符在结尾时匹配 server_name 成功4. 正则表达式匹配 server_name 成功 基于 IP 地址的虚拟主机配置语法结构和基于域名匹配一样，而且不需要考虑通配符和正则表达式的问题。1server_name 192.168.1.1 location用于匹配 URL12 location [ = | ~ | ~* | ^~] uri &#123; &#125; = ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。 ~ ：用于表示 uri 包含正则表达式，并且区分大小写。 ~* ：用于表示 uri 包含正则表达式，并且不区分大小写。 ^~ ：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。 注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识 proxy_pass设置代理服务器的地址,可以是 主机名称、IP 地址加端口，URI 等1prox_pass URL 配置图解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133#user nobody; # user 指定运行 nginx 的用户和组（第一个参数为用户第二个为组，这里只有用户）worker_processes 1; #运行时使用CPU的个数#error_log logs/error.log; # 指定错误日志为 logs/ 目录下的 error.log 文件#error_log logs/error.log notice; # 指定错误日志，并指定写入格式为 notice#error_log logs/error.log info; # 指定错误日志，并指定写入格式为 info#pid logs/nginx.pid; # 指定 pid 文件（存放主进程 pid 号）events &#123; worker_connections 1024; #一个woeker进程的最大连接数&#125;#Nginx用作虚拟主机时使用。每一个server模块生成一个虚拟主机。http &#123; include mime.types; #定义MIME类型和后缀名关联的文件的位置 default_type application/octet-stream; #指定mime.types文件中没有记述到的后缀名的处理方法 # 写入格式 main 的内容格式如下 #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; # 指定访问日志和写入格式为 main sendfile on; #是 否使用OS的sendfile函数来传输文件 #tcp_nopush on; # 启用或者禁用使用套接字选项（仅在 sendfile 使用时使用） #keepalive_timeout 0; # 0 值禁用保持活动的客户端连接 keepalive_timeout 65; #HTTP连接的持续时间。设的太长会使无用的线程变的太多 #gzip on; # 启用或者禁用 gzip # 虚拟主机配置模块 server &#123; listen 8888; #监听端口 server_name localhost; #服务地址 charset utf-8; #编码方式 #charset koi8-r; #root /var/www; #你的网站根目录 root /Users/b/Desktop; error_log logs/error.log; #access_log logs/host.access.log main; location /a/ &#123; alias /Users/b/Desktop/Nginx_files/; # 别名 index 6.gif IMG_2021.jpg; # 定义索引，按顺序匹配 &#125; #若按照上述配置的话，则访问/a/目录里面的文件时，ningx会自动去/Users/b/Desktop/Nginx_files/目录找文件 # 将特定的文件或目录重新定位，如 php 文件，image 目录等 location /Nginx_files/ &#123; root /Users/b/Desktop; index 6.gif IMG_2021.jpg; # 定义索引，按顺序匹配 &#125; #若按照这种配置的话，则访问/Nginx_files/目录下的文件时，nginx会去/Users/b/Desktop/Nginx_files/目录下找文件。 error_page 404 /404.html; # 定义显示 404 错误的 uri # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; # location 精准匹配 &apos;/50x.html&apos; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # 正则表达式: .php文件走的路径 # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; #走fastcgi 路径 # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; #定义的根目录 以及 请求的脚名 # include fastcgi_params; # 请求参数 #&#125; # deny access to .htaccess files, if Apache&apos;s document root # concurs with nginx&apos;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; include servers/*;&#125; 参考文档 苗泽老师的《Nginx高性能Web服务器详解》","categories":[{"name":"服务器","slug":"服务器","permalink":"http://blog.bevexed.top/categories/服务器/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.bevexed.top/tags/Nginx/"}]},{"title":"前端设计模式（状态模式）","slug":"前端设计模式（状态模式）","date":"2019-09-06T02:08:22.000Z","updated":"2019-09-06T03:00:59.283Z","comments":true,"path":"2019/09/06/前端设计模式（状态模式）/","link":"","permalink":"http://blog.bevexed.top/2019/09/06/前端设计模式（状态模式）/","excerpt":"","text":"介绍 一个对象有状态变化 每次状态变化都会触发一个逻辑 不能总是用 if…else 来控制 demo123456789101112131415161718192021222324252627282930313233343536373839class State &#123; constructor(color) &#123; this.color = color &#125; handel() &#123; console.log(`turn to $&#123; this.color &#125; light`); context.setState(this) &#125;&#125;class Context &#123; constructor() &#123; this.state = null &#125; getState() &#123; return this.state &#125; setState(state) &#123; this.state = state &#125;&#125;let context = new Context();let green = new State('green');let yellow = new State('yellow');let red = new State('red');green.handel();console.log(context.getState());yellow.handel();console.log(context.getState());red.handel();console.log(context.getState()); 应用场景 ES6 Promise","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/tags/设计模式/"}]},{"title":"前端设计模式（迭代器模式）","slug":"前端设计模式（迭代器模式）","date":"2019-09-05T09:52:11.000Z","updated":"2019-09-06T02:05:06.451Z","comments":true,"path":"2019/09/05/前端设计模式（迭代器模式）/","link":"","permalink":"http://blog.bevexed.top/2019/09/05/前端设计模式（迭代器模式）/","excerpt":"","text":"介绍 顺序访问一个集合 使用者无需知道集合的内部结构（封装） demo1234567891011121314151617181920212223242526272829303132333435class Iterator &#123; constructor(container) &#123; this.list = container.list; this.index = 0; &#125; next() &#123; if (this.hasNext()) &#123; return this.list[this.index++] &#125; return null &#125; hasNext() &#123; return this.index &lt; this.list.length; &#125;&#125;class Container &#123; constructor(list) &#123; this.list = list &#125; // 生成遍历器 getIterator() &#123; return new Iterator(this) &#125;&#125;let arr = [1, 2, 3, 4, 5];let container = new Container(arr);let iterator = container.getIterator();while (iterator.hasNext())&#123; console.log(iterator.next());&#125; 应用场景 jQuery each ES6 Iterator ES6 语法中，有序集合的数据类型已经有很多 Array Map Set String TypedArray arguments NodeList 都有 [Symbol.iterator] 属性 属性值是函数，执行函数返回一个迭代器 迭代器有 next 方法可以顺序迭代子元素 可运行 Array.prototype[Symbol.iterator] 测试 实现 1234567891011121314151617function each(data) &#123; // 生成遍历器 let iterator = data[Symbol.iterator](); let item; do &#123; item = iterator.next(); if (!item.done) &#123; console.log(item.value); &#125; &#125; while (!item.done)&#125;let arr = [1, 2, 3, 4, 5, 6];each(arr); for…of 语法糖 123456789function each(data) &#123; for (let item of data)&#123; console.log(item); &#125;&#125;let arr = [1, 2, 3, 4, 5, 6];each(arr); 需要有一个统一的遍历接口来遍历所有的数据类型 （Object 不是有序集合，可以用 Map 代替）","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/tags/设计模式/"}]},{"title":"前端设计模式（观察者模式）","slug":"前端设计模式（观察者模式）","date":"2019-08-26T07:32:01.000Z","updated":"2019-09-05T09:54:11.156Z","comments":true,"path":"2019/08/26/前端设计模式（观察者模式）/","link":"","permalink":"http://blog.bevexed.top/2019/08/26/前端设计模式（观察者模式）/","excerpt":"","text":"介绍 发布 &amp; 订阅 一对多 主题 和 观察者分离，不是主动触发而是被动监听，两者解耦 demo12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Subject &#123; constructor()&#123; this.state = 0 this.observers = [] &#125; getState()&#123; return this.state &#125; setState(state)&#123; this.state = state this.notifyAllObservers() &#125; notifyAllObservers()&#123; this.observers.forEach(observer =&gt; &#123; observer.update() &#125;) &#125; attach(observer)&#123; this.observers.push(observer) &#125;&#125;class Observer &#123; constructor(name, subject)&#123; this.name = name this.subject = subject this.subject.attach(this) &#125; update()&#123; console.log(`$&#123; this.name &#125; update, state: $&#123; this.subject.getState() &#125;`); &#125;&#125;let s = new Subject()let o1 = new Observer('o1', s)let o2 = new Observer('o2', s)s.setState(1)s.setState(2)s.setState(3) 应用场景 网页事件绑定 Promise 的 then jQuery callbacks vue 和 React 组件声明周期触发 nodejs 自定义事件 使用 12345678910111213const EventEmitter = require('events').EventEmitter;const emitter1 = new EventEmitter();// 监听 some 事件emitter1.on('some', info =&gt;&#123; console.log('fn1', info);&#125;);// 监听 some 事件emitter1.on('some', info =&gt;&#123; console.log('fn2', info);&#125;);// 触发 some 事件emitter1.emit('some','xxx'); 继承 1234567891011121314151617const EventEmitter = require('events').EventEmitter;class Dog extends EventEmitter &#123; constructor(name)&#123; super() this.name = name &#125;&#125;let xxx = new Dog('xxx');xxx.on('bark', () =&gt; &#123; console.log(this.name, 'barked-1');&#125;)xxx.on('bark', () =&gt; &#123; console.log(this.name, 'barked-2');&#125;)xxx.emit('bark') 网页事件绑定123$('#btn1').click(function() &#123; console.log(1);&#125;)","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/tags/设计模式/"}]},{"title":"前端设计模式（外观模式）","slug":"前端设计模式（外观模式）","date":"2019-08-26T07:20:09.000Z","updated":"2019-08-26T07:30:06.124Z","comments":true,"path":"2019/08/26/前端设计模式（外观模式）/","link":"","permalink":"http://blog.bevexed.top/2019/08/26/前端设计模式（外观模式）/","excerpt":"","text":"介绍 为子系统中的一组接口提供了一个高层接口 使用者使用这个高层接口 业务用的比较多","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/tags/设计模式/"}]},{"title":"前端设计模式（代理模式）","slug":"前端设计模式（代理模式）","date":"2019-08-26T06:23:32.000Z","updated":"2019-08-26T07:19:42.271Z","comments":true,"path":"2019/08/26/前端设计模式（代理模式）/","link":"","permalink":"http://blog.bevexed.top/2019/08/26/前端设计模式（代理模式）/","excerpt":"","text":"介绍 使用者无权访问目标对象 中间加代理，通过代理做授权和控制 demo123456789101112131415161718192021222324class ReadImg &#123; constructor(fileName)&#123; this.fileName = fileName this.loadFromDisk() &#125; loadFromDisk()&#123; console.log('loading...' + this.fileName); &#125; display()&#123; console.log('display...' + this.fileName); &#125;&#125;class ProxyImg &#123; constructor(fileName) &#123; this.realImg = new ReadImg(fileName) &#125; display()&#123; this.realImg.display() &#125;&#125;let proxyImg = new ProxyImg()proxyImg.display() 应用 网页事件代理（冒泡模型） jQuery的$.proxy ES6 Proxy 网页事件代理（冒泡模型）1234567891011121314151617181920212223242526&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset=\"UTF-8\"&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"div1\"&gt; &lt;a href=\"#\"&gt;1&lt;/a&gt; &lt;a href=\"#\"&gt;2&lt;/a&gt; &lt;a href=\"#\"&gt;3&lt;/a&gt; &lt;a href=\"#\"&gt;4&lt;/a&gt;&lt;/div&gt;&lt;script&gt; const div1 = document.querySelector('#div1'); div1.addEventListener('click', function (e) &#123; console.log(e); const &#123; target &#125; = e; if (target.nodeName === 'A') &#123; alert(target.innerHTML) &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ES6 Proxy123456789101112131415161718192021222324252627282930313233let star = &#123;name: 'xxx',age: 25,phone: 123&#125;let agent = new Proxy(star, &#123; get(target ,key)&#123; if(key === 'phone')&#123; return '321' &#125; if(key === 'price')&#123; return 12000 &#125; return target[key] &#125;, set(target, key, value, receiver) &#123; if (key === 'customPrice')&#123; if(value &lt; 100000)&#123; throw new Error('价格太低') &#125; else &#123; return value &#125; &#125; &#125;&#125;)console.log(agent.phone);console.log(agent.name);console.log(agent.age);agent.customPrice = 1000000 代理模式 VS 适配器模式 适配器模式：提供一个不同的接口 代理模式：提供一个一模一样的接口 代理模式 VS 装饰器模式 装饰器模式：扩展功能，原有功能不变且可以直接使用 代理模式：显示原有功能，但是经过限制或者阉割之后的","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/tags/设计模式/"}]},{"title":"前端设计模式（装饰器模式）","slug":"前端设计模式（装饰器模式）","date":"2019-08-19T09:30:31.000Z","updated":"2019-08-26T06:32:20.969Z","comments":true,"path":"2019/08/19/前端设计模式（装饰器模式）/","link":"","permalink":"http://blog.bevexed.top/2019/08/19/前端设计模式（装饰器模式）/","excerpt":"","text":"介绍 为对象添加新功能 应用 旧接口的封装 Vue computed ES7123456789101112131415161718192021222324252627282930313233// npm i babel-plugin-transform-decorators-legacy -D// .babelrc \"plugins\": [\"transform-decorators-legacy\"]@testDecclass Demo &#123;&#125;function testDec(target) &#123; target.isDec = true&#125;alert(Demo.isDec)// 实例二function mixins(...list) &#123; return function(target) &#123; Object.assign(target.prototype, ...list) &#125;&#125;const Foo = &#123; foo()&#123; alert('foo') &#125;&#125;@mixins(Foo)class MyClass &#123; &#125;let obj = new MyClass()obj.foo() demo123456789101112131415161718192021222324class Circle &#123; draw()&#123; console.log('圆'); &#125;&#125;class Decorator &#123; constructor(circle)&#123; this.circle = circle &#125; draw()&#123; this.circle.draw() this.setRedBorder(circle) &#125; setRedBorder(circle)&#123; console.log('红色边框'); &#125;&#125;let circle = new Circle()circle.draw()let dec = new Decorator(circle)dec.draw() 装饰方法1234567891011121314function readonly(target, name, descriptor) &#123; descriptor.writable = false&#125;class Person &#123; constructor()&#123; this.first = 'A' this.last = 'B' &#125; @readonly name()&#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125; 1234567891011121314151617181920function log(target, name ,descriptor) &#123; console.log(target,name,descriptor); let oldValue = descriptor.value descriptor.value = function() &#123; console.log(`calling $&#123;name&#125; width`,arguments) return oldValue.apply(this, arguments) &#125; return descriptor&#125;class Math &#123; @log add(a, b)&#123; return a + b &#125;&#125;let math = new Math();console.log(math.add(1, 2)); core-decorators 装饰器库 安装1&gt; npm i core-decorators -S 常用api deprecate readonly","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/tags/设计模式/"}]},{"title":"前端设计模式（适配器模式）","slug":"前端设计模式（适配器模式）","date":"2019-08-19T09:17:39.000Z","updated":"2019-08-19T08:59:17.683Z","comments":true,"path":"2019/08/19/前端设计模式（适配器模式）/","link":"","permalink":"http://blog.bevexed.top/2019/08/19/前端设计模式（适配器模式）/","excerpt":"","text":"介绍 旧接口和现有接口不一致，需要转换 应用 旧接口的封装 Vue computed demo123456789101112131415161718class Adaptee &#123; specificRequest()&#123; return '220v' &#125;&#125;class Target &#123; constructor()&#123; this.adaptee = new Adaptee() &#125; request()&#123; let info = this.adaptee.specificRequest() return '110v' &#125;&#125;let target = new Target()target.request()","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/tags/设计模式/"}]},{"title":"前端设计模式（单例模式）","slug":"前端设计模式（单例模式）","date":"2019-08-19T08:07:29.000Z","updated":"2019-08-19T08:47:24.315Z","comments":true,"path":"2019/08/19/前端设计模式（单例模式）/","link":"","permalink":"http://blog.bevexed.top/2019/08/19/前端设计模式（单例模式）/","excerpt":"","text":"介绍 系统中被唯一使用 一个类只有一个实例 强依赖 于 private 应用 登录框 123456789101112131415161718192021222324252627282930313233class LoginForm &#123; constructor() &#123; this.state = 'hide' &#125; show()&#123; if(this.state === 'show')&#123; return alert('已经显示') &#125; this.state = 'show' console.log('显示成功'); &#125; hide() &#123; if(this.state === 'hide')&#123; return alert('已经隐藏') &#125; this.state = 'hide' console.log('隐藏成功'); &#125;&#125;LoginForm.getInstance = (function() &#123; let instance return function() &#123; if(!instance)&#123; instance = new LoginForm() &#125; return instance &#125;&#125;)()let login = LoginForm.getInstance()login.show() 购物车 jQuery 只有一个 $12345if(window.jQuery != null)&#123; return window.jQuery&#125; else &#123; // 初始化。。。&#125; demo1234567891011121314151617181920class SingleObject &#123; login() &#123; console.log('login'); &#125;&#125;SingleObject.getInstance = (function() &#123; let instance return function() &#123; if(!instance)&#123; instance = new SingleObject() &#125; return instance &#125;&#125;)()let obj1 = SingleObject.getInstance()console.log(obj1);let obj2 = SingleObject.getInstance()console.log(obj2);","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/tags/设计模式/"}]},{"title":"前端设计模式（工厂模式）","slug":"前端设计模式（工厂模式）","date":"2019-08-19T08:07:29.000Z","updated":"2019-08-19T08:18:55.570Z","comments":true,"path":"2019/08/19/前端设计模式（工厂模式）/","link":"","permalink":"http://blog.bevexed.top/2019/08/19/前端设计模式（工厂模式）/","excerpt":"","text":"工厂模式 将 new 操作单独封装 遇到 new 时，可以考虑使用 工厂模式 demo123456789101112131415161718class Product &#123; constructor(name)&#123; this.name = name &#125; init()&#123; &#125;&#125;class Creator &#123; create(name)&#123; return new Product(name) &#125;&#125;let creator = new Creator()let p = creator.create('demo')p.init() 实例 jQuery 12345678910111213141516171819class jQuery &#123; constructor(selector)&#123; let slice = Array.prototype.slice; let dom = slice.call(document.querySelectorAll(selector)); let len = dom ? dom.length : 0; for(let i = 0; i &lt; len; i++)&#123; this[i] = dom[i] &#125; this.length = len; this.selector = selector || ''; &#125; append(node)&#123; // ... &#125;&#125;window.$ = function(selector) &#123; return new jQuery(selector)&#125; React.createElement","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/tags/设计模式/"}]},{"title":"前端设计模式（设计原则）","slug":"前端设计模式（设计原则）","date":"2019-08-19T02:52:20.000Z","updated":"2019-08-19T03:53:07.282Z","comments":true,"path":"2019/08/19/前端设计模式（设计原则）/","link":"","permalink":"http://blog.bevexed.top/2019/08/19/前端设计模式（设计原则）/","excerpt":"","text":"何为设计 按照一种思路或标准来实现功能 功能相同，可以用不同的方案来实现 随着需求的增加，设计的作用才能体现出来 《UNIX/LINUX设计哲学》 小即是美 让每个程序只做好一件事 快速建立原型 舍去高效率而取可移植性 采用纯文本来存储数据 充分利用软件的杠杆效应 使用 shell 脚本来提高杠杆效应和可移植性 避免强制性的用户界面 让每个程序都成为过滤器 允许用户定制环境 尽量使操作系统内核小而轻量化 使用小写字母并尽量简写 沉默是金 各部分之和大于整体 寻求百分之90的解决方案 如何学习 明白每个设计的道理和用意 通过经典应用体会他的真正使用场景 自己编码时多思考，尽量模仿（刻意训练） SOLID五大设计原则 S：单一职责原则 O：开放封闭原则 L：李氏置换原则 I：接口堵路原则 D：依赖倒置原则 单一职责原则 一个程序只做好一件事 如果功能过于浮渣就拆分开，每个部分保持独立 开放封闭原则 对扩展开放，对修改封闭 增加需求时，扩展新代码，而非修改已有代码 软件设计的终极目标 李氏置换原则 子类能够覆盖父类 父类能处闲的地方子类就能出现 JS 种使用较少 接口独立原则 保持接口的单一独立，避免出现“胖接口” 依赖倒置原则 面向接口编程，依赖于抽象而不依赖于具体 使用方只关注接口而不关注具体类的实现 从设计到模式23种设计模式 创建型 组合型 行为型 创建型 工厂模式（工厂方法模式、抽象工厂模式、建造者模式） 单例模式 原型模式 结构型 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 行为型 策略模式 模板方法模式 观察者模式（JS中用的多） 迭代器模式 职责链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/tags/设计模式/"}]},{"title":"webpack搭建简单环境","slug":"webpack搭建简单环境","date":"2019-07-30T07:22:57.000Z","updated":"2019-08-19T02:25:26.030Z","comments":true,"path":"2019/07/30/webpack搭建简单环境/","link":"","permalink":"http://blog.bevexed.top/2019/07/30/webpack搭建简单环境/","excerpt":"","text":"初始化 npm npm init 安装 webpack、webpack-cli npm i webpack webpack-cli -S 新建 webpack.dev.config.js1234567module.exports = &#123; entry: './src/index.js', output: &#123; path: __dirname, filename: \"./release/bundle.js\" &#125;&#125;; 新建 src 目录 src index.js index.html 在 package.json 配置123456&#123; \"scripts\": &#123; \"test\": \"\", \"dev\": \"webpack --config ./webpack.dev.config --mode development\" &#125;&#125; 安装插件 webpack-dev-server html-webpack-plugin npm i webpack-dev-server html-webpack-plugin -S 修改 webpack.dev.config.js12345678910111213141516171819202122const path = require('path');const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; entry: './src/index.js', output: &#123; path: __dirname, filename: \"./release/bundle.js\" &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: \"./index.html\" &#125;) ], devServer: &#123; contentBase: path.join(__dirname,'./release'), //根目录 open: true, port: 9000 &#125;&#125;; 修改 package.json “dev”: “webpack-dev-server –config ./webpack.dev.config –mode development” 安装 babel 解析 ES6 babel-core babel-loader babel-polyfill babel-preset-env babel-preset-latest npm i babel-core babel-loader babel-polyfill babel-preset-env babel-preset-latest -S 新建 .babelrc1234567&#123; \"presets\": [ \"es2015\", \"latest\" ], \"plugins\": []&#125; 在 webpack.dev.config 中配置 loader1234567module: &#123; rules: [&#123; test: /\\.js?$/, exclude: /(node_modules)/, loader: 'babel-loader' &#125;] &#125;","categories":[{"name":"构建工具","slug":"构建工具","permalink":"http://blog.bevexed.top/categories/构建工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://blog.bevexed.top/tags/webpack/"}]},{"title":"前端设计模式（面向对象）","slug":"前端设计模式（面向对象）","date":"2019-07-30T07:10:25.000Z","updated":"2019-08-19T02:21:56.288Z","comments":true,"path":"2019/07/30/前端设计模式（面向对象）/","link":"","permalink":"http://blog.bevexed.top/2019/07/30/前端设计模式（面向对象）/","excerpt":"","text":"设计模式 学会设计模式，可以帮你写更好的代码 编程应该 简单、抽象 面向对象 数据结构化 概念 类：模板 对象：实例 三要素 继承 继承可以将公共方法抽离出来，提高复用，减少冗余 封装（ES6不支持，ts 支持） public 完全开放 protected 对子类开放 private 对自己开放 减少耦合，不该外露不外露 利于数据、接口的权限管理 多态 同一个接口不同，不同表现 JS 应用极少 保持子类的开放性和灵活性 面向接口编程 应用jQuery12345678910111213141516171819class jQuery &#123; constructor(selector)&#123; let slice = Array.prototype.slice; let dom = slice.call(document.querySelectorAll(selector)); let len = dom ? dom.length : 0; for(let i = 0; i &lt; len; i++)&#123; this[i] = dom[i] &#125; this.length = len; this.selector = selector || ''; &#125; append(node)&#123; // ... &#125;&#125;window.$ = function(selector) &#123; return new jQuery(selector)&#125; demo1234567891011121314151617181920212223242526272829303132333435363738394041class Person &#123; constructor(name,age)&#123; this.name = name; this.age= age &#125; getName()&#123; return this.name &#125; eat()&#123; alert(`$&#123;this.name&#125; eat something`) &#125; speak()&#123; alert(`My name is $&#123;this.name&#125;,age $&#123;this.age&#125;`) &#125;&#125;let p = new Person('webPack',1)alert(p.getName())p.eat()p.speak()class Student extends Person &#123; constructor(name, age, number) &#123; super(name, age); this.number = number &#125; study() &#123; alert(`学号：$&#123; this.number &#125;`) &#125;&#125;let w = new Student('w', 2, 3);w.study();w.eat();w.speak();","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.bevexed.top/tags/设计模式/"}]},{"title":"TCP/IP","slug":"TCP-IP","date":"2019-07-16T04:56:06.000Z","updated":"2019-07-16T05:29:44.979Z","comments":true,"path":"2019/07/16/TCP-IP/","link":"","permalink":"http://blog.bevexed.top/2019/07/16/TCP-IP/","excerpt":"","text":"分层 大多数的网络应用程序都被设计成了 客户端 - 服务器 模式 双方都有对应的 一或多个 协议进行通讯 链路层、网络层、运输层 一般在内核中执行，应用程序通常是用户进程 链路层、网络层、运输层 关注通讯细节 应用层 关注应用程序 应用层和运输层使用端到端（end-to-end）协议- 链路层（以太网/ARP/硬件接口）处理与电缆（或其他任何传输媒介）的物理接口细节 网络层（IP/ICMP/IGMP）处理分组在网络中的活动，例如分组选路 提供逐跳协议（hop-to-hop） 网络ip提供的是一种不可靠的服务，他只是尽可能快的把分组从源结点送到目的结点，但不提供可靠性保障 ICMP 是 IP 协议的附属协议（告诉你出问题的原因） ICMP运输层（TCP/UDP）为两台主机上的应用程序提供端到端的通讯 TCP 在不可靠的IP层上提供了一个可靠的运输层 UDP 不可靠 应用层（FTP）处理特定的应用程序细节 互联网的目的之一就是在应用程序中隐藏所有的物理细节","categories":[{"name":"网络基础","slug":"网络基础","permalink":"http://blog.bevexed.top/categories/网络基础/"}],"tags":[{"name":"基础","slug":"基础","permalink":"http://blog.bevexed.top/tags/基础/"}]},{"title":"二叉堆","slug":"二叉堆","date":"2019-06-13T05:55:15.000Z","updated":"2019-06-13T10:15:10.012Z","comments":true,"path":"2019/06/13/二叉堆/","link":"","permalink":"http://blog.bevexed.top/2019/06/13/二叉堆/","excerpt":"","text":"二叉堆 本质是一种 完全二叉树 有 最小堆 和 最大堆 两种 二叉堆的根节点叫做 堆顶 最大堆的堆顶是整个堆中的 最大元素 最小堆的堆顶是整个堆中的 最小元素 最大堆任何一个 父节点 的值，都 大于或等于 它左、右孩子节点的值 最小堆任何一个 父节点 的值，都 小于或等于 它左、右孩子节点的值 二叉堆的自我调整把一个不符合堆性质的完全二叉树，调整成一个堆，操作有 插入节点 删除节点 构建二叉堆 插入节点 二叉堆插入节点时，插入位置是完全二叉树的 最后 一个位置 新节点通过与父节点比较位置和 上浮 来确认节点的位置 删除节点 二叉堆删除的是 堆顶 的节点 此时为了维持二叉堆的结构，需要用 最后一个 节点临时补充到堆顶的位置 通过 下沉 来确认节点的位置 构建二叉堆 通过所有子叶 下沉 实现 下沉从最后一个节点开始 二叉堆的所有节点都存储在 数组 中 如果父节点的下标是 parent，则左孩子的下标为 2 * parent + 1，右孩子的下标为 2 * parent + 2","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.bevexed.top/categories/算法/"}],"tags":[]},{"title":"","slug":"树/exercise","date":"2019-06-13T05:44:01.337Z","updated":"2019-06-13T05:44:01.352Z","comments":true,"path":"2019/06/13/树/exercise/","link":"","permalink":"http://blog.bevexed.top/2019/06/13/树/exercise/","excerpt":"","text":"Binary Tree .root { display: flex; border: 1px solid #000; width: 600px; margin: 0 auto; height: 150px; align-items: center; justify-content: center; } .root div { display: flex; height: 70%; width: 44%; margin: 0 3%; border: 1px solid #000; justify-content: center; align-items: center; background: #fff; } 1 2 4 5 3 6 7 /** * 深度优先遍历的递归写法 * 原理：递归的回溯性 */ class TravelTree { constructor() { this.nodeList = []; } preOrder = node => { if (node) { this.nodeList.push(node.firstChild.textContent.trim()); this.preOrder(node.firstElementChild); this.preOrder(node.lastElementChild); } }; inOrder = node => { if (node) { this.inOrder(node.firstElementChild); this.nodeList.push(node.firstChild.textContent.trim()); this.inOrder(node.lastElementChild); } }; postOrder = node => { if (node) { this.postOrder(node.firstElementChild); this.postOrder(node.lastElementChild); this.nodeList.push(node.firstChild.textContent.trim()); } }; reset() { this.nodeList = []; } } let node = document.querySelector('.root'); let tree = new TravelTree(); console.log('TravelTree'); tree.reset(); tree.preOrder(node); console.log(tree.nodeList); tree.reset(); tree.inOrder(node); console.log(tree.nodeList); tree.reset(); tree.postOrder(node); console.log(tree.nodeList); // 深度优先遍历的非递归写法 class StackTree { constructor() { this.nodeList = []; this.stack = [] } preOrder(node) { let treeNode = node; while (treeNode || this.stack.length) { // 进栈 将所有左节点压栈 while (treeNode) { this.stack.push(treeNode); this.nodeList.push(treeNode.firstChild.textContent.trim()); treeNode = treeNode.firstElementChild; } // 出栈 if (this.stack.length) { treeNode = this.stack.pop(); treeNode = treeNode.lastElementChild; } } } inOrder(node) { let treeNode = node; while (treeNode || this.stack.length) { while (treeNode) { this.stack.push(treeNode); treeNode = treeNode.firstElementChild; } if (this.stack.length) { treeNode = this.stack.pop(); this.nodeList.push(treeNode.firstChild.textContent.trim()); treeNode = treeNode.lastElementChild; } } } /* * 将根节点压入第一个栈 * 从第一个栈中弹出一个元素，压入第二个栈 * 然后分别将该节点的左右孩子压入第一个栈 * 重复步骤2和步骤3直到第一个栈为空 * 执行结束，第二个栈中就保存了所有节点的后序遍历输出结果。依次将元素从第二个栈中弹出即可。 */ postOrder(node) { let treeNode = node; this.stack.push(treeNode); while (this.stack.length) { treeNode = this.stack.pop(); this.nodeList.unshift(treeNode.firstChild.textContent.trim()); if (treeNode.firstElementChild) { this.stack.push(treeNode.firstElementChild) } if (treeNode.lastElementChild) { this.stack.push(treeNode.lastElementChild) } } } reset() { this.stack = []; this.nodeList = []; } } let stackTree = new StackTree(); console.log('stackTree'); stackTree.preOrder(node); console.log(stackTree.nodeList); stackTree.reset(); stackTree.inOrder(node); console.log(stackTree.nodeList); stackTree.reset(); stackTree.postOrder(node); console.log(stackTree.nodeList); // 广度度优先遍历非递归 class WidthTravelTree { constructor() { this.nodeList = []; this.stack = [] } // 队列 widthTravel(node) { if (node) { this.stack.push(node); this.nodeList.push(node.firstChild.textContent.trim()); while (this.stack.length) { let item = this.stack.shift(); if (item.firstElementChild) { this.nodeList.push(item.firstElementChild.firstChild.textContent.trim()); this.stack.push(item.firstElementChild); } if (item.lastElementChild) { this.nodeList.push(item.lastElementChild.firstChild.textContent.trim()); this.stack.push(item.lastElementChild) } } } } } console.log('WidthTravelTree'); let widthTravelTree = new WidthTravelTree(); widthTravelTree.widthTravel(node); console.log(widthTravelTree.nodeList);","categories":[],"tags":[]},{"title":"","slug":"树/demo","date":"2019-06-10T09:21:29.548Z","updated":"2019-06-11T09:18:56.233Z","comments":true,"path":"2019/06/10/树/demo/","link":"","permalink":"http://blog.bevexed.top/2019/06/10/树/demo/","excerpt":"","text":"Document * { margin: 0; padding: 0; } .wrap { display: flex; border: 1px solid #000; width: 600px; margin: 0 auto; height: 150px; align-items: center; justify-content: center; } .wrap div { display: flex; height: 70%; width: 44%; margin: 0 3%; border: 1px solid #000; justify-content: center; align-items: center; background: #fff; } .btn-wrap { text-align: center; padding-top: 20px; } .btn-wrap button { display: inline-block; padding: 4px 10px; } 前序 中序 后序 let wrap = document.querySelector(\".wrap\"); let btn_wrap = document.querySelector(\".btn-wrap\"); let btn1 = btn_wrap.querySelectorAll(\"button\")[0]; let btn2 = btn_wrap.querySelectorAll(\"button\")[1]; let btn3 = btn_wrap.querySelectorAll(\"button\")[2]; let arr = []; let last; let toggle = false; //给按钮绑定事件 btn1.onclick = function () { if (!toggle) { toggle = true; reset(); preOrder(wrap); showWay(); } }; btn2.onclick = function () { if (!toggle) { toggle = true; reset(); inOrder(wrap); showWay(); } }; btn3.onclick = function () { if (!toggle) { toggle = true; reset(); postOrder(wrap); showWay(); } }; //二叉树的遍历的三种方式 //(1)前序遍历（DLR) function preOrder(node) { if (node) { arr.push(node); preOrder(node.firstElementChild); preOrder(node.lastElementChild); } } //(2)中序遍历（LDR） function inOrder(node) { if (node) { inOrder(node.firstElementChild); arr.push(node); inOrder(node.lastElementChild); } } //(3)后序遍历（LRD） function postOrder(node) { if (node) { postOrder(node.firstElementChild); postOrder(node.lastElementChild); arr.push(node); } } //显示遍历的过程 function showWay() { for (let i = 0; i < arr.length; i++) { setTimeout(function (i) { return function () { if (i === arr.length - 1) { toggle = false; } if (last) { last.style.background = \"white\"; } arr[i].style.background = \"red\"; last = arr[i]; } }(i), i * 1000) } } //初始化 function reset() { arr = []; if (last) { last.style.background = \"white\"; } }","categories":[],"tags":[]},{"title":"树","slug":"树","date":"2019-05-15T09:11:36.000Z","updated":"2019-06-13T09:53:11.864Z","comments":true,"path":"2019/05/15/树/","link":"","permalink":"http://blog.bevexed.top/2019/05/15/树/","excerpt":"","text":"树 tree 树（tree）是n（n&gt;=0）个节点的有限集合。 当 n=0 时，称为空树 在任意一个非空树中有如下特点 有且仅有一个特定的称为 根（root） 的节点 当 n&gt;1 时，其余节点可分为m（m&gt;0）个互不相交的有限集，每一个集合本身又是一个树，称为根的 子树 节点的末端，叫做 叶子节点（leaf） 二叉树 binary tree 树的一种特殊结构 每个节点最多有两个子节点 二叉树节点的两个孩子节点，一个被称为 左孩子（left child），一个被称为 右孩子（right child） 这两个孩子顺序固定，不可颠倒 存储结构 链式存储结构 数组 满二叉树 一个二叉树的所有非叶子节点都存在左右孩子 所有叶子节点都在同一层级上 完全二叉树 对一个有 n 个节点的二叉树，按层级顺序编号，则所有节点的编号为从 1 到 n 。如果这个树所有节点和同样深度的满二叉树的编号为从 1 到 n 的节点位置相同，则这个二叉树为完全二叉树 二叉查找树 也叫二叉排序树 如果左子树不为空，则左子树上所有节点的值均小于根节点的值 如果右子树不为空，则右子树上所有节点的值均大于根节点的值 左右子树也是二叉树查找 对于一个 节点分布相对均衡 的二叉查找树来说，如果节点总数是 n，那么搜索节点的时间复杂度为 O(logn),和数的深度一样 二叉树的自平衡 二叉树与存储结构链式存储结构二叉树的每一个节点由三部分组成 存储数据的 data 变量 指向左孩子的 left 指针 指向右孩子的 right 指针 数组存储结构 按照层级顺序把二叉树的节点放到数组的对应位置上 如果某一节点的左孩子或右孩子空缺，则数组的相应位置也空出来 假设一个父节点的下标为 parent，那么它的左孩子的下标为 2 * parent + 1，它的右孩子的下标为 2 * parent + 2 假设一个左孩子的下标为 leftChilde ，那么他的父节点的下标为 (leftChild - 1) / 2 应用二叉查找树（binary search tree）二叉查找树在二叉树的基础上增加了以下条件 如果左子树不为空，则左子树上所有节点的值均小于根节点的值 如果右子树不为空，则右子树上所有节点的值均大于根节点的值 左右子叶也是二叉树查找 时间复杂度 O(logn), n 为树的深度 维持相对顺序 二叉查找树的左子树小于父节点，右子树大于父节点，保证了二叉树的有序性 二叉树遍历将 非线性的数据结构 转换成 线性的序列 深度优先遍历 (demo)偏向于深度，一头扎到底的访问方式 前序遍历（DLR) 过程 先访问 根节点 遍历 左子树 遍历 右子树 结果 : ABDECF 中序遍历（LDR） 过程左 根 右 结果 : DBEACF 后序遍历（LRD） 过程左 右 根 结果 ： DEBFCA demo123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Binary Tree&lt;/title&gt; &lt;style&gt; .root &#123; display: flex; border: 1px solid #000; width: 600px; margin: 0 auto; height: 150px; align-items: center; justify-content: center; &#125; .root div &#123; display: flex; height: 70%; width: 44%; margin: 0 3%; border: 1px solid #000; justify-content: center; align-items: center; background: #fff; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class=\"root\"&gt; 1 &lt;div&gt;2 &lt;div&gt;4&lt;/div&gt; &lt;div&gt;5&lt;/div&gt; &lt;/div&gt; &lt;div&gt;3 &lt;div&gt;6&lt;/div&gt; &lt;div&gt;7&lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;script&gt; /** * 深度优先遍历的递归写法 * 原理：递归的回溯性 */ class TravelTree &#123; constructor() &#123; this.nodeList = []; &#125; preOrder = node =&gt; &#123; if (node) &#123; this.nodeList.push(node.firstChild.textContent.trim()); this.preOrder(node.firstElementChild); this.preOrder(node.lastElementChild); &#125; &#125;; inOrder = node =&gt; &#123; if (node) &#123; this.inOrder(node.firstElementChild); this.nodeList.push(node.firstChild.textContent.trim()); this.inOrder(node.lastElementChild); &#125; &#125;; postOrder = node =&gt; &#123; if (node) &#123; this.postOrder(node.firstElementChild); this.postOrder(node.lastElementChild); this.nodeList.push(node.firstChild.textContent.trim()); &#125; &#125;; reset() &#123; this.nodeList = []; &#125; &#125; let node = document.querySelector('.root'); let tree = new TravelTree(); console.log('TravelTree'); tree.reset(); tree.preOrder(node); console.log(tree.nodeList); tree.reset(); tree.inOrder(node); console.log(tree.nodeList); tree.reset(); tree.postOrder(node); console.log(tree.nodeList); // 深度优先遍历的非递归写法 class StackTree &#123; constructor() &#123; this.nodeList = []; this.stack = [] &#125; preOrder(node) &#123; let treeNode = node; while (treeNode || this.stack.length) &#123; // 进栈 将所有左节点压栈 while (treeNode) &#123; this.stack.push(treeNode); this.nodeList.push(treeNode.firstChild.textContent.trim()); treeNode = treeNode.firstElementChild; &#125; // 出栈 if (this.stack.length) &#123; treeNode = this.stack.pop(); treeNode = treeNode.lastElementChild; &#125; &#125; &#125; inOrder(node) &#123; let treeNode = node; while (treeNode || this.stack.length) &#123; while (treeNode) &#123; this.stack.push(treeNode); treeNode = treeNode.firstElementChild; &#125; if (this.stack.length) &#123; treeNode = this.stack.pop(); this.nodeList.push(treeNode.firstChild.textContent.trim()); treeNode = treeNode.lastElementChild; &#125; &#125; &#125; /* * 将根节点压入第一个栈 * 从第一个栈中弹出一个元素，压入第二个栈 * 然后分别将该节点的左右孩子压入第一个栈 * 重复步骤2和步骤3直到第一个栈为空 * 执行结束，第二个栈中就保存了所有节点的后序遍历输出结果。依次将元素从第二个栈中弹出即可。 */ postOrder(node) &#123; let treeNode = node; this.stack.push(treeNode); while (this.stack.length) &#123; treeNode = this.stack.pop(); this.nodeList.unshift(treeNode.firstChild.textContent.trim()); if (treeNode.firstElementChild) &#123; this.stack.push(treeNode.firstElementChild) &#125; if (treeNode.lastElementChild) &#123; this.stack.push(treeNode.lastElementChild) &#125; &#125; &#125; // todo: 单个栈的实现方法 reset() &#123; this.stack = []; this.nodeList = []; &#125; &#125; let stackTree = new StackTree(); console.log('stackTree'); stackTree.preOrder(node); console.log(stackTree.nodeList); stackTree.reset(); stackTree.inOrder(node); console.log(stackTree.nodeList); stackTree.reset(); stackTree.postOrder(node); console.log(stackTree.nodeList); // 广度度优先遍历非递归 class WidthTravelTree &#123; constructor() &#123; this.nodeList = []; this.stack = [] &#125; // 队列 widthTravel(node) &#123; if (node) &#123; this.stack.push(node); this.nodeList.push(node.firstChild.textContent.trim()); while (this.stack.length) &#123; let item = this.stack.shift(); if (item.firstElementChild) &#123; this.nodeList.push(item.firstElementChild.firstChild.textContent.trim()); this.stack.push(item.firstElementChild); &#125; if (item.lastElementChild) &#123; this.nodeList.push(item.lastElementChild.firstChild.textContent.trim()); this.stack.push(item.lastElementChild) &#125; &#125; &#125; &#125; &#125; console.log('WidthTravelTree'); let widthTravelTree = new WidthTravelTree(); widthTravelTree.widthTravel(node); console.log(widthTravelTree.nodeList);&lt;/script&gt;&lt;/html&gt; 广度优先遍历 层序遍历 资料参考 图片来源","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.bevexed.top/categories/算法/"}],"tags":[]},{"title":"数据结构基础","slug":"数据结构基础","date":"2019-05-14T09:14:47.000Z","updated":"2019-05-15T08:55:59.530Z","comments":true,"path":"2019/05/14/数据结构基础/","link":"","permalink":"http://blog.bevexed.top/2019/05/14/数据结构基础/","excerpt":"","text":"数据结构 数据的组织、管理和存储格式 提高数据的访问和修改效率分类 线性结构 数组、链表 栈、对、列、哈希表 树 二叉树 二叉堆 图 其他数据结构 跳表、哈希链表、位图、散列表 数组 array 有限个相同类型变量组成的有序集合 数组中的每一个变量被称为元素 数组是最简单最为常用的数据结构 在内存中顺序存储 读取数组元素和更新数组元素的时间复杂度都是 O(1) 数组的插入和删除操作的时间复杂度为 O(n) 适用于读操作多，写操作少的情景 链表 link list 链表是一种物理上非连续、非顺序的数据结构，由若干个节点(node)组成 链表中的第一个节点叫做节点头，最后一个节点被称为节点尾，尾节点的 next 指针指向空 在内存中随机存储 链表查询节点的最坏时间复杂度为 O(n) 链表更新、插入、删除节点的时间复杂度为 O(1)– 适用于写操作多，读操作少的情景单向链表 单向链表的每一个节点包涵两部分 一部分存放数据变量data 另一部分是指向下一个节点的指针 next 一级一级，单线传递双向链表 每一个节点都拥有 data，next指针 和 prev指针 双向传递 栈 stack 一种线性数据结构 栈中元素只能先入后出（First In Last Out，简称 FILO） 最早进入的元素存放的位置叫栈底（bottom） 最后进入的元素存放的位置叫栈顶（top） 数据结构即可以用数组实现，也可以用链表实现操作 入栈 入栈操作（push）是把新元素放入栈中 只允许从栈顶一侧放入元素 新元素的位置成为新的栈顶 出栈 出栈操作（pop）是把元素从栈中弹出 只有栈顶元素才允许出栈 出栈元素的前一个元素会成为新的栈顶 出栈和入栈的时间复杂度都是 O(1)应用 历史回溯 面包屑导航 队列 queue 一种线性的数据结构 队列中的元素先入先出（First In First Out，简称 FIFO） 队列的出口端叫做队头（front） 队列的入口端叫做队尾（rear）操作 入队 入队（queue）是把新元素放入队列中 只允许在队尾的位置放置新元素 新元素的下一个位置将会成为下一个队尾 出队 出队（dequeue）是把元素移出队列， 只允许在队头一侧移出元素 出队元素后的一个元素将成为队头 队列循环 出队和入队的时间复杂度都是 O(1)应用 多线程，争夺公平锁的等待队列 双端队列 deque 综合栈和队列的优缺点 优先队列 基于二叉堆实现 散列表 也叫哈希表（hash table） 提供了键（key）和值（value）的映射关系 只要给出一个 key,就可以高效的查找他说匹配的 Value，时间复杂度接近于 O(1) 本质是数组，通过哈希函数转换操作 写操作（put） 通过哈希函数，把 key 转换为数值下标 如果下标对应的位置没有元素，将键值对插入到当前位置 当下标对应的位置已经存在元素，就会出现哈希冲突 哈希冲突的主要解决方式是开放寻址法和链表法 读操作（get） 通过哈希函数，把 key 转换为数值下标 通过在链表内匹配 key 值，寻找节点 扩容（resize） 原因 当经过多次元素插入，散列表达到一定饱和度时，key 映射位置发生冲突的概率会逐渐提高 大量元素拥挤在相同的数组下标位置，会形成很长的链表，对后续的读写抄作有很大的性能影响 这时，散列表需要扩展他的长度 过程 扩容，创建一个新的 Entry 空数组，长度是原数组的2倍 重新Hash，遍历原 Entry 数组，把所有的 Entry 重新 Hash 到新数组中","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.bevexed.top/categories/算法/"}],"tags":[]},{"title":"算法","slug":"算法","date":"2019-05-14T08:04:30.000Z","updated":"2019-05-14T09:15:26.719Z","comments":true,"path":"2019/05/14/算法/","link":"","permalink":"http://blog.bevexed.top/2019/05/14/算法/","excerpt":"","text":"算法algorithm 来自数学领域的一个古老概念。 在计算机领域里，指一系列程序指令，用于处理特定的运算和逻辑能力 特性 有简单的也有复杂的 有高效的也有笨拙的 应用领域 运算 求两个数的最大公约数 查找 在数据库执行 SQL语句 排序 电商商品排序 最优决策 A星寻路算法 算法好坏评判标准其中算法好坏有很多标准，其中重要的两大标准是时间复杂度与空间复杂度 渐进时间复杂度 执行算法的时间成本 对算法运行时间长短的量度 若存在函数 f(n)，使得当 n 趋近于无穷大时，T(n)/f(n) 的极限值为不等于零的常数，则称 f(n) 是 T(n) 的同数量级函数。记作 T(n) = O(f(n))，称为 O(f(n))，O 为算法的渐进时间复杂度，简称为时间复杂度推导时间复杂度的基本原则 如果运行时间是常数量级，则用常数1表示 只保留时间函数中的最高阶项 如果最高阶项存在，则省去最高阶项前的系数 当取值足够大时，O(1)&lt; O(logn)&lt; O(n)&lt; O(nlogn)&lt; O(n²) 空间复杂度 执行算法的空间成本 算法在运行过程中临时占用存储空间大小的度量 程序占用空间大小的计算公式记作 S(n)=O(f(n))，其中 n 为问题的规模，f(n)为算法所占存储空间的函数空间复杂度的计算 常量空间 当算法的存储空间大小固定，和输入的规模没有直接的关系时，空间复杂度记作 O(1) 线性空间 当算法分配的空间是一个线性的集合（如数组），并且集合大小和输入规模 成中比时，空间复杂度记作 O(n) 二维空间 当算法分配的空间是一个二维数组集合，并且集合的长度和宽度都与输入规模 n 成正比时，空间复杂度记作 O(n²) 递归空间 递归算法的空间复杂度和递归深度成正比","categories":[{"name":"算法","slug":"算法","permalink":"http://blog.bevexed.top/categories/算法/"}],"tags":[]},{"title":"Generator","slug":"Generator","date":"2019-05-13T08:17:55.000Z","updated":"2019-06-12T01:47:32.125Z","comments":true,"path":"2019/05/13/Generator/","link":"","permalink":"http://blog.bevexed.top/2019/05/13/Generator/","excerpt":"","text":"基本概念 Generator函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数不同 语法上，可以将它理解成一个状态机，封装了多个内部状态 执行上，他是一个遍历器对象生成函数。 执行 Generator函数 会返回一个遍历器对象， 返回的遍历器对象可以依次遍历Generator函数内部的每一个状态 形式上，Generator函数是一个普通函数，但是有两个特征： function命令与函数名之间有一个星号 函数体内部使用 yield 语句来定义不同的内部状态123456789// 定义 一个 Generator 函数function* hellow() &#123; yield 'he'; // 状态语句 yield 'll'; yield 'ow'; return 'ending'; // 结束语句&#125; let hw = hellow(); Generator函数的调用方法和普通函数一样。但是， 调用后该函数不会执行 返回的不是函数运行的结果，而是一个指向内部状态的指针对象，也就是遍历器对象（Iterator Object） 必须调用对象的next方法，使指针移向下一个状态 每次调用next方法，会返回一个包函value和done两个属性的对象。 value：内部状态值 done：布尔值 ，表示是否遍历结束 yield 表达式yield语句就是暂停标志 next方法的运行逻辑 遇到yield就暂停执行后边的操作，并将紧跟其后的表达式的值作为返回对象的value属性值 下一次调用 next方法 时会继续向下执行，知道遇到下一条yield语句 如果没有遇到新的yield语句就一直运行到函数结束，直到return语句为止，并将return语句后面表达式的值作为返回对象的value属性值 如果没有return语句则返回undefined yield语句与return语句 两者都返回紧跟在语句后面的表达式的值 yield语句具有记忆功能，return语句不具有此功能 一个函数只能执行一次return语句，但是可以执行多条yield语句 暂缓执行函数当Generator函数不包含yield语句时，就变成了一个暂缓执行函数1234567function* f() &#123; console.log(1);&#125;let g = f(); // 此时不执行setTimeout(function() &#123; g.next() // 只有调用 next 以后才执行&#125;,3000) 注意事项 yield语句只能用在Generator函数中，用在其他地方会报错 不可以用在 forEach等方法的回调函数内，可以使用for循环代替 yield表达式如果在另一个表达式中，必须放在圆括号内 123function* f() &#123; console.log(1+(yield 2));&#125; yield表达式作为函数参数或放在赋值表达式的右边可以不加括号 与Generator接口的关系 任意一个对象的Symbol.iterator方法等于该对像的遍历器对象生成函数，调用该函数会返回该对象的一个遍历器对象 由于Generator函数就是遍历器生成函数，所以可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口 123456let myIterable = [];myIterable[Symbol.iterator] = function*() &#123; yield 1; yield 2;&#125;;console.log([...myIterable]) // [1, 2] Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身12345function* f() &#123; console.log(1);&#125;let g = f();console.log(g[Symbol.iterator] === g); // true next方法的参数 yield语句本身没有返回值，或者说总是返回undefined next 方法可以带有一个参数，该参数会被当做上一条 yield语句的返回值 由于 next 方法的参数表示上一条yield语句的返回值，所以第一次使用 next 方法时，传递参数是无效的 如果希望第一次调用 next 方法时能过输入值，可以在 Generator函数 外再包一层 for…of循环 for…of 循环可以自动遍历 Generator函数 生成的 Iterator 对象，且此时不需要调用 next 方法。 一旦 next 方法的返回对象的 done 属性为 true，for…of循环就会终止，且不包含返回的对象12345678function* f() &#123; yield 1; yield 2; return 3;&#125;for (let v of foo())&#123; console.log(v); // 1 2 不包含 return语句返回的 3&#125; Generator.prototype.throw() Generator函数返回的遍历器对象都有一个 throw 方法，可以在函数体外抛出错误，然后再 Generator函数 内捕获；反过来，Generator函数体内抛出的错误也可以被函数体外的 catch 捕获 如果 Generator函数 内部没有部署 try…catch 代码块，那么 throw 方法抛出的错误将被外部的 try…catch 代码块捕获 如果 Generator函数 内部部署了 try…catch 代码块，那么遍历器的 throw 方法抛出的错误不影响下一次遍历，否则遍历会终止 一旦Genertator函数执行过程中抛出错误，就不会往下执行了，如果此后调用 next 方法，将返回 {value: undefined, done: true} 这个对象 throw 方法执行后会附带执行下一条 yield 表达式，即附带执行一次 next 方法 throw 命令与 Generator.prototype.throw()方法互不影响12345678910111213141516171819let g = function*() &#123; try &#123; yield ; &#125;catch (e) &#123; console.log('内部捕获',e); &#125;&#125;;let i = g();i.next();try &#123; i.throw('a'); i.throw('b');&#125;catch (e) &#123; console.log('外部捕获',e);&#125;// 内部捕获 a// 外部捕获 b Generator.prototype.return() 该方法返回给定的值,并终结Generator函数的遍历 如果不提供参数，则返回值的 value 属性为 undefined 123456789function* f() &#123; yield 1; yield 2;&#125;let g = f();g.next(); // &#123;value: 1, done &#125;g.return('foo'); // &#123;value: 'foo', done: true&#125;g.next() // &#123;value: undefined, deone: true&#125; 如果Generator函数内部有 try…finally 代码块，那么 return 方法会推迟到 finally 代码块执行完成在执行 123456789101112131415161718function* f() &#123; yield 1; try &#123; yield 2; yield 3; &#125; catch (e) &#123; yield 4; yield 5; &#125; yield 6;&#125;let g = f();g.next(); // &#123; value: 1, done: false &#125;g.next(); // &#123; value: 2, done: false&#125;g.return(); // &#123; value: 4, done: false&#125;g.next(); // &#123; value: 5, done: false&#125;g.next(); // &#123; value: 7, done: true&#125; yield* 表达式 如果在一个Generator函数内调用另一个Generator函数，默认情况下是没有效果的 12345678910111213function* a() &#123; yield 'a';&#125;function* b() &#123; a(); yield 'b';&#125;for (let v of b())&#123; console.log(v); // 'b'&#125; // a 和 b 都是 Generator函数 在b中调用a不会生效 yield*，用来在一个Generator函数里执行另一个Generator函数 123456789101112function* a() &#123; yield 'a';&#125;function* b() &#123; yield* a(); yield 'b';&#125;for (let v of b())&#123; console.log(v); // 'a' 'b'&#125; 如果 yield 命令后面跟的是一个遍历器对象，那么需要在 yield 命令后面加上星号，表明返回的是一个遍历器对象 123456789101112131415161718192021222324function* inner() &#123; yield 'hellow'&#125;function* outer1() &#123; yield 'open'; yield inner(); yield 'colse'&#125;let gen = outer1();gen.next().value; // 'open'gen.next().value; // 返回一个遍历器对象gen.next().value; // 'colse'function* outer2() &#123; yield 'open'; yield* inner(); yield 'close';&#125;let gen2 = outer2();gen2.next().value; // 'open'gen2.next().value; // 'hellow'gen2.next().value; // 'close' yield* 后面的Generator语句没有 return 语句时等同于在Generator函数内部部署了一个 for...of 循环 yield 后面的Generator语句有 return 语句时，需要用 `let value = yield iterator` 的形式获取 return语句的值 如果被代理的Generator语句有 return 语句，那么可以向代理他的Generator函数返回数据 任何数据只要有Iterator接口，就可以被yield*遍历123456789101112let a = (function*() &#123; yield 'hellow'; yield* 'he'; yield* [1,2,3] &#125;());a.next().value; // 'hellow'a.next().value; // 'h'a.next().value; // 'e'a.next().value; // '1'a.next().value; // '2'a.next().value; // '3' 应用 异步操作的同步化表达 控制流管理 部署 Iterator 接口 作为数据结构","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://blog.bevexed.top/categories/JavaScript/"}],"tags":[{"name":"异步","slug":"异步","permalink":"http://blog.bevexed.top/tags/异步/"}]},{"title":"函数节流与函数防抖","slug":"函数节流与函数防抖","date":"2019-04-26T02:39:53.000Z","updated":"2019-04-28T02:46:48.482Z","comments":true,"path":"2019/04/26/函数节流与函数防抖/","link":"","permalink":"http://blog.bevexed.top/2019/04/26/函数节流与函数防抖/","excerpt":"","text":"函数节流 throttle 限制一个函数在一定时间内只执行一次 上拉加载 屏幕滚动 高频点击 实现1234567891011121314const _.throttle = (func, wait) =&gt; &#123; let timer; return () =&gt; &#123; if (timer) &#123; return; &#125; timer = setTimeout(() =&gt; &#123; func(); timer = null; &#125;, wait); &#125;;&#125;; 函数防抖 debounce 事件触发后 n秒 内只执行一次，如果 n秒 内再次触发事件，则重新计算函数执行时间 一个动作连续触发，只执行最后一次 应用场景 搜索 手机号、邮箱验证 窗口改变 实现12345678const _.debounce = (func, wait) =&gt; &#123; let timer; return () =&gt; &#123; clearTimeout(timer); timer = setTimeout(func, wait); &#125;;&#125;; 异同比较相同点 都可以通过 setTimeout 实现 都是降低回调执行频率，节省计算资源 不同点 函数防抖，在一段连续操作结束后，处理回调函数，利用 clearTimeout 和 setTimeout 实现。 函数节流，在一段连续操作中，每一段时间只执行一次，频率较高的事件中使用来提高性能。 函数防抖，关注一段时间连续触发，只在最后一次执行 函数节流，侧重一段时间只执行一次 参考文章 浅析函数防抖与函数节流","categories":[{"name":"性能优化","slug":"性能优化","permalink":"http://blog.bevexed.top/categories/性能优化/"}],"tags":[{"name":"事件监听","slug":"事件监听","permalink":"http://blog.bevexed.top/tags/事件监听/"}]},{"title":"indexedDB","slug":"indexedDB","date":"2019-04-02T10:18:51.000Z","updated":"2020-01-26T06:04:18.681Z","comments":true,"path":"2019/04/02/indexedDB/","link":"","permalink":"http://blog.bevexed.top/2019/04/02/indexedDB/","excerpt":"","text":"特征NoSQL 数据库 不支持 SQL 查询语句 不属于 关系型数据库 键值对存储 采用对象仓库（object store）存放数据 所有数据都可以直接存入，包括 JavaScript对象 每一条数据都有 独一无二的 主键对应，重复会报错 异步 不会锁死浏览器 支持事务（transaction） 只要一步失败，整个事务取消，数据库回滚到事务发生之前的状态 同源限制 每一个数据库都有一个与之对应的域名 不能跨域访问数据库 存储空间大 一般 不小于250M 支持二进制存储 可以存储 ArrayBuffer对象 和 Blob对象 基本概念 数据库：IDBDatabase 对象 对象仓库：IDBObjectStore 对象 索引： IDBIndex 对象 事务： IDBTransaction 对象 操作请求：IDBRequest 对象 指针：IDBCursor 对象 主键集合：IDBKeyRange 对象 数据库 数据库是一些列相关数据的容器。 每个域名（协议+域名+端口）都可以创建任意多个数据库 IndexedDB 数据库有版本的概念,同一时间只能有一个版本的数据库存在。 修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。 对象仓库 每个数据库包涵若干个对象仓库，类似于关系数据库中的表格。 索引 为了加快数据检索，在对象仓库里，为不同属性建立索引。 事务 数据记录的读写和删除，倒要通过事务完成。 事务对象提供 error、abort、complete 三个事件，用来监听操作结果。 数据记录 对象仓库保存的是数据记录。 每条记录类似于关系型数据库的行，但是只有主键和数据体两个部分。 主键用来建立默认的索引，必须是不同的，否则会报错 主键可以是数据记录里面的一个属性，也可以是一个递增的整数编号 操作打开数据库 indexedDB.open() 参数1：数据库名字 指定数据库不存在，新建数据库 参数2：数据库版本 新建数据库版本默认为 1 1const request = window.indexedDB.open('databaseName', version); 返回一个 IDBRequest 对象 该对象通过 error 、 success 、 upgradeneeded 三种事件处理打开数据库的操作结果error123request.onerror = function (event) &#123; console.log('数据库打开报错', event);&#125;; success 通过request对象的result属性拿到数据库对象。 123456let db;request.onsuccess = function (event) &#123; db = request.result; console.log('数据库打开成功');&#125;; upgradeneeded 当指定的版本号大于 实际操作的版本号，触发该事件。 通过事件对象的target.result属性，拿到数据库实例。12345let db;request.onupgradeneeded = function (event) &#123; db = event.target.result;&#125; 新建数据库 新建数据库和打开数据库是同一操作 打开数据库后的后续操作主要在 upgradeneeded 中操作 新建对象仓库 createObjectStore() 参数1：表格名字 参数2：主键配置 { autoIncrement: true } // IndexedDB 自动生成主键。 { keyPath: ‘id’ } // 自定义主键为 ‘id’ 12345678910let dbrequest.onupgradeneeded = function(event) &#123; db = event.target.result; let objectStore; // 检测表格是否 存在 if (!db.objectStoreNames.contains('person')) &#123; // 新建一张叫做 person 的表格 ，主键是 id objectStore = db.createObjectStore('person', &#123; keyPath: 'id' &#125;); &#125;&#125; 创建索引 createIndex() 参数1：索引名称 参数2：索引所在属性 参数1：配置对象 { unique: false } // 该属性是否包涵重复的值123456request.onupgradeneeded = function(event) &#123; let db = event.target.result; let objectStore = db.createObjectStore('person', &#123; keyPath: 'id' &#125;); objectStore.createIndex('name', 'name', &#123; unique: false &#125;); objectStore.createIndex('email', 'email', &#123; unique: true &#125;);&#125; 新增数据 向对象仓库写入数据记录 需要通过新建事务完成 新建时必须指定 表格名城 和 操作模式（‘只读’、‘读写’） 新建事务后 通过 IDBTransaction.objectStore(name) 方法，拿到 IDBObjectStore 对象 通过 add() 方法向表格 写入数据 写入操作是一个 异步操作，通过监听链接对象的 success 和 error 事件，判断是否写入成功 12345678910111213function add() &#123; let request = db.transaction(['person'], 'readwrite') .objectStore('person') .add(&#123; id: 1, name: '张三', age: 24, email: 'zhangsan@example.com' &#125;); request.onsuccess = function (event) &#123; console.log('数据写入成功', event); &#125;; request.onerror = function (event) &#123; console.log('数据写入失败', event); &#125;&#125; 读取数据 读取数据也通过事务完成12345678910111213141516171819function read() &#123; let transaction = db.transaction(['person']); let objectStore = transaction.objectStore('person'); let request = objectStore.get(1); request.onerror = function(event) &#123; console.log('事务失败'); &#125;; request.onsuccess = function(event) &#123; if (request.result) &#123; console.log('Name: ' + request.result.name); console.log('Age: ' + request.result.age); console.log('Email: ' + request.result.email); &#125; else &#123; console.log('未获得数据记录'); &#125; &#125;;&#125; 遍历数据 openCursor() 遍历数据表格的所有记录，要使用指针对象 IDBCursor openCursor() 方法是一个异步操作，需要监听 success 事件返回的结果1234567891011121314151617function readAll() &#123; let objectStore = db.transaction('person').objectStore('person'); objectStore.openCursor().onsuccess = function (event) &#123; let cursor = event.target.result; if (cursor) &#123; console.log('Id: ' + cursor.key); console.log('Name: ' + cursor.value.name); console.log('Age: ' + cursor.value.age); console.log('Email: ' + cursor.value.email); cursor.continue(); &#125; else &#123; console.log('没有更多数据了！'); &#125; &#125;;&#125; 更新数据 IDBObject.put()12345678910111213function update() &#123; let request = db.transaction(['person'], 'readwrite') .objectStore('person') .put(&#123; id: 1, name: '李四', age: 35, email: 'lisi@example.com' &#125;); request.onsuccess = function (event) &#123; console.log('数据更新成功'); &#125;; request.onerror = function (event) &#123; console.log('数据更新失败'); &#125;&#125; 删除数据 openCursor()123456789function remove() &#123; let request = db.transaction(['person'], 'readwrite') .objectStore('person') .delete(1); request.onsuccess = function (event) &#123; console.log('数据删除成功'); &#125;;&#125; 使用索引 索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录 123456789101112131415objectStore.createIndex('name', 'name', &#123; unique: false &#125;);let transaction = db.transaction(['person'], 'readonly');let store = transaction.objectStore('person');let index = store.index('name');let request = index.get('李四');request.onsuccess = function (e) &#123; let result = e.target.result; if (result) &#123; // ... &#125; else &#123; // ... &#125;&#125; indexedDB 对象 浏览器提供的原生对象 indexedDB.open() 打开数据库 异步操作 立即返回一个 IDBOpenDBRequest 对象 12// 打开一个名为 test 版本为 1 的数据库，如果数据库不存在则创建该数据库let openRequest = window.indexedDB.open('test', 1); 参数 参数1：数据库名称 格式为字符串，不可省略 参数2：数据库版本 大于 0 的正整数 ，0 会报错 该参数大于当前版本，会触发数据库升级 该参数可以省略，如果数据库已存在，打开最新版本数据库；如果数据库不存在，创建该版本的数据库，默认版本为 1 回调事件 success：打开成功 error：打开失败 upgradeneeded：第一次打开该数据库，或数据库版本发生变化 blocked：上一次的数据库连接还未关闭 第一次打开数据库，会先触发 upgradeneeded 事件，然后触发 success 事件success 事件发生后，从 openRequest.result 属性可以拿到已经打开的 IndexedDB 数据库对象 12345678910111213141516let openRequest = indexedDB.open('test', 1);let db;openRequest.onupgradeneeded = function (e) &#123; console.log('Upgrading...');&#125;openRequest.onsuccess = function (e) &#123; console.log('Success!'); db = openRequest.result;&#125;openRequest.onerror = function (e) &#123; console.log('Error'); console.log(e);&#125; indexedDB.deleteDatabase() 用于删除一个数据库 立即返回一个 IDBOpenDBRequest 对象，然后对数据库执行异步删除 删除不存在的数据库时，不会报错 当调用该方法后，当前数据的其他已经打开的连接都会接收到 versionchange 事件 参数 数据库名字 回调事件 success：删除成功 error：删除失败123456789let DBDeleteRequest = window.indexedDB.deleteDatabase('demo');DBDeleteRequest.onerror = function (event) &#123; console.log('Error');&#125;;DBDeleteRequest.onsuccess = function (event) &#123; console.log('success');&#125;; indexedDB，cmp() 比较两个值是否为 indexedDB 的相同的主键。 返回一个整数，表示比较的结果 0 ：相同 1： 第一个主键大于第二个主键 -1： 第一个主键小于第二个主键1234window.indexedDB.cmp(1, 2); // -1// 注意，这个方法不能用来比较任意的 JavaScript 值。如果参数是布尔值或对象，它会报错。window.indexedDB.cmp(1, true); // 报错window.indexedDB.cmp(&#123;&#125;, &#123;&#125;) // 报错 IDBRequest 对象 表示打开的数据库连接 indexedDB.open() 和 indexedDB.deleteDatabase() 方法会返回这个对象 数据库的操作都是通过此对象完成 对象的所有操作都是 异步 完成 通过 readyState 属性判断是否完成 pending：正在进行 done：完成，有可能失败也有可成功 操作完成，触发 error 或 success 事件 可以通过 result 属性 和 error 属性 拿到操作结果 如果在 pending 状态去读取这两个属性的值会报错属性 IDBRequest.readyState：等于pending表示操作正在进行，等于done表示操作正在完成。 IDBRequest.result：返回请求的结果。如果请求失败、结果不可用，读取该属性会报错。 IDBRequest.error：请求失败时，返回错误对象。 IDBRequest.source：返回请求的来源（比如索引对象或 ObjectStore）。 IDBRequest.transaction：返回当前请求正在进行的事务，如果不包含事务，返回null。 IDBRequest.onsuccess：指定success事件的监听函数。 IDBRequest.onerror：指定error事件的监听函数。 插件level.js","categories":[{"name":"HTML5","slug":"HTML5","permalink":"http://blog.bevexed.top/categories/HTML5/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://blog.bevexed.top/tags/数据库/"}]},{"title":"browser-sync 安装与使用","slug":"browser-sync","date":"2019-04-02T06:35:48.000Z","updated":"2019-04-02T06:42:54.317Z","comments":true,"path":"2019/04/02/browser-sync/","link":"","permalink":"http://blog.bevexed.top/2019/04/02/browser-sync/","excerpt":"","text":"browser-sync 浏览器同步工具 安装1&gt; npm i browser-sync -g 使用1&gt; browser-sync init 普通使用1&gt; browser-sync start --server --files \"**\" 跨域1&gt; browser-sync start --proxy \"localhost:8080\" --files \"**\"","categories":[{"name":"构建工具","slug":"构建工具","permalink":"http://blog.bevexed.top/categories/构建工具/"}],"tags":[]},{"title":"rc-queue-anim的使用","slug":"rc-queue-anim的使用","date":"2019-02-18T01:56:50.000Z","updated":"2019-02-18T02:06:37.337Z","comments":true,"path":"2019/02/18/rc-queue-anim的使用/","link":"","permalink":"http://blog.bevexed.top/2019/02/18/rc-queue-anim的使用/","excerpt":"","text":"安装1&gt; npm i -S rc-queue-anim 使用harmony12345678910import QueueAnim from 'rc-queue-anim';ReactDOM.render( &lt;QueueAnim delay=&#123;300&#125; className=\"queue-simple\"&gt; &lt;div key=\"a\"&gt;依次进场&lt;/div&gt; &lt;div key=\"b\"&gt;依次进场&lt;/div&gt; &lt;div key=\"c\"&gt;依次进场&lt;/div&gt; &lt;div key=\"d\"&gt;依次进场&lt;/div&gt; &lt;/QueueAnim&gt;, mountNode); 官网https://motion.ant.design/","categories":[{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/categories/React/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://blog.bevexed.top/tags/插件/"},{"name":"动画","slug":"动画","permalink":"http://blog.bevexed.top/tags/动画/"}]},{"title":"socket.io","slug":"socket-io","date":"2019-02-15T05:46:52.000Z","updated":"2019-04-26T02:48:36.644Z","comments":true,"path":"2019/02/15/socket-io/","link":"","permalink":"http://blog.bevexed.top/2019/02/15/socket-io/","excerpt":"","text":"安装1&gt; npm install socket.io -S 使用客户端12345678910111213import io from 'socket.io-client'// 得到与服务器的链接对象const socket = io('ws://localhost:9000');// 接收消息socket.on('receiveMsg', function (data) &#123; console.log('浏览器接收消息');&#125;)// 发送消息socket.emit('sendMsg', &#123;name: '12', data: Date.now()&#125;)console.log('发送消息'); 服务端123456789101112131415161718module.exports = function (server) &#123; const io = require('socket.io')(server); // 监视客户端与服务器端的链接 io.on('connection',function (socket) &#123; console.log('链接成功'); socket.on('sendMsg',function (data) &#123; console.log('服务器接受到浏览器消息'); // 全局发数据 io.emit('receiveMsg',data.name+'_'+data.data) // 单一发数据 socket.emit('receiveMsg',data.name+'_'+data.data) console.log('服务器向浏览器发消息'); &#125;) &#125;)&#125;// wwwrequire('../socketIO/test')(server); 参考网站 https://socket.io/get-started/chat/ https://blog.csdn.net/neuq_zxy/article/details/77531126","categories":[{"name":"Node","slug":"Node","permalink":"http://blog.bevexed.top/categories/Node/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://blog.bevexed.top/tags/插件/"},{"name":"Node","slug":"Node","permalink":"http://blog.bevexed.top/tags/Node/"}]},{"title":"js-cookie","slug":"js-cookie","date":"2019-02-14T03:48:21.000Z","updated":"2019-02-14T03:54:28.798Z","comments":true,"path":"2019/02/14/js-cookie/","link":"","permalink":"http://blog.bevexed.top/2019/02/14/js-cookie/","excerpt":"","text":"安装1&gt; yarn add js-cookie -S cdn1&lt;script src=\"https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js\"&gt;&lt;/script&gt; 使用1import Cookies from 'js-cookie' apiCookies.set123Cookies.set('name', 'value');Cookies.set('name', 'value', &#123; expires: 7 &#125;);Cookies.set('name', 'value', &#123; expires: 7, path: '' &#125;); Cookies.get123Cookies.get('name'); // =&gt; 'value'Cookies.get('nothing'); // =&gt; undefinedCookies.get(); // =&gt; &#123; name: 'value' &#125; Cookies.remove1Cookies.remove('name'); 参考网站https://www.npmjs.com/package/js-cookie","categories":[{"name":"插件","slug":"插件","permalink":"http://blog.bevexed.top/categories/插件/"}],"tags":[{"name":"cookie","slug":"cookie","permalink":"http://blog.bevexed.top/tags/cookie/"},{"name":"插件","slug":"插件","permalink":"http://blog.bevexed.top/tags/插件/"}]},{"title":"redux的使用","slug":"redux的使用","date":"2019-02-13T06:11:39.000Z","updated":"2019-02-18T02:29:31.976Z","comments":true,"path":"2019/02/13/redux的使用/","link":"","permalink":"http://blog.bevexed.top/2019/02/13/redux的使用/","excerpt":"","text":"文档 https://www.redux.org.cn/ redux 模块 redux模块整体是一个对象模块 内部包含的函数： createStore(reducers) // reducers:fucntion(state,action)(return newState) combineReducers(reducers) // reducers:{reducer1,reducer2} 返回：function(state,action){rteturn newState} applyMiddleware() 安装基本包1&gt; npm install --save redux react-redux redux-thunk redux-devtools-extension 开发工具1npm install --save-dev redux-devtools 使用目录结构reduxstore.jsredux 最核心的管理模块1234567import &#123;createStore,applyMiddleware&#125; from \"redux\";import thunk from 'redux-thunk'import &#123;composeWithDevTools&#125; from \"redux-devtools-extension\";import reducers from './reducers'// 向外暴露 store 对象export default createStore(reducers,composeWithDevTools(applyMiddleware(thunk))) reducers.js包含 n 个 reducer 函数 根据老的 state 和 指定的 action 返回一个 新的 state1234567891011121314151617// 合并状态import &#123;combineReducers&#125; from \"redux\"; import &#123;AUTH_SUCCESS, ERROR_MSG&#125; from \"./action-types\";export const register = (user) =&gt; &#123; return async dispatch =&gt; &#123; // 发送注册的异步 ajax 请求 const result = await reqRegister(user) console.log(result); if (result.code === 0) &#123; // 分发成功的同步action dispatch(authSuccess(result.data)) &#125; else &#123; dispatch(errprMsg(result.msg)) &#125; &#125;&#125; actioncs.js包含 n 个 action creator 异步 action 同步 action 1234import &#123; AUTH_SUCCESS, ERROR_MSG&#125; from \"./action-types\"; action-types.js包含 n 个 action-type 常量12export const AUTH_SUCCESS='auth_success'export const ERROR_MSG='error_msg' app.js引入Provider、storejsx12345678910111213141516171819import &#123;Provider&#125; from 'react-redux'import store from './redux/store'class App extends Component &#123; render() &#123; return ( &lt;div className=\"App\"&gt; &lt;Provider store=&#123;store&#125;&gt; &lt;HashRouter&gt; &lt;Switch&gt; &lt;Route exact path='/register' component=&#123;Register&#125;/&gt; &lt;Route exact path='/login' component=&#123;Login&#125;/&gt; &lt;Route component=&#123;Main&#125;/&gt; &#123;/* 默认组件*/&#125; &lt;/Switch&gt; &lt;/HashRouter&gt; &lt;/Provider&gt; &lt;/div&gt; ); &#125;&#125; 参考文章Redux 入门教程 https://cn.vuejs.org/v2/guide/state-management.html https://vuex.vuejs.org/ https://cn.redux.js.org/docs/react-redux/ http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_two_async_operations.html http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_three_react-redux.html https://redux-saga-in-chinese.js.org https://juejin.im/post/59e6cd68f265da43163c2821 https://react-redux.js.org/introduction/why-use-react-redux https://segmentfault.com/a/1190000007248878 http://es6.ruanyifeng.com/#docs/generator https://juejin.im/post/5ac1cb9d6fb9a028cf32a046 https://zhuanlan.zhihu.com/p/35437092 https://github.com/dvajs/dva/issues/1 https://cn.mobx.js.org https://zhuanlan.zhihu.com/p/25585910 http://imweb.io/topic/59f4833db72024f03c7f49b4","categories":[{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/categories/React/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://blog.bevexed.top/tags/插件/"},{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/tags/React/"}]},{"title":"react技术选型","slug":"react技术选型","date":"2019-02-13T05:40:52.000Z","updated":"2019-02-13T08:04:12.452Z","comments":true,"path":"2019/02/13/react技术选型/","link":"","permalink":"http://blog.bevexed.top/2019/02/13/react技术选型/","excerpt":"","text":"前台数据展示/交互/组件化react-router-dom npm i react-router-dom -S redux npm i redux react-redux redux-thunk redux-devtools-extension -S antd-mobile npm i -D babel-plugin-import react-app-rewired 引入 看文档 按需打包 后台项目 node express mongodb mongoose socket.io 前后台交互 ajax 请求 axios async / await测试 API 接口 postman模块化 ES6 babel 项目构建/工程化 webpack react-create-app eslint 其他相关库 blueimp-md5 js-cookie rc-queue-anim","categories":[{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/categories/React/"}],"tags":[{"name":"插件","slug":"插件","permalink":"http://blog.bevexed.top/tags/插件/"},{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/tags/React/"}]},{"title":"react-router-dom的简单使用","slug":"react-router-dom的使用","date":"2019-02-13T02:19:28.000Z","updated":"2019-02-15T07:38:11.389Z","comments":true,"path":"2019/02/13/react-router-dom的使用/","link":"","permalink":"http://blog.bevexed.top/2019/02/13/react-router-dom的使用/","excerpt":"","text":"安装1&gt; yarn add react-router react-router-dom -S 引入1import &#123;Swtich, Route, Router, HashHistory, Link&#125; from 'react-router-dom'; 简单使用1234567&lt;HashRouter&gt; &lt;Switch&gt; &lt;Route exact path='/' component=&#123;home&#125;&gt;1212&lt;/Route&gt; &lt;Route exact path='/a' component=&#123;a&#125;&gt;12321312&lt;/Route&gt; &lt;Route component=&#123;a&#125;&gt;12321312&lt;/Route&gt; &#123;/* 默认组件*/&#125; &lt;/Switch&gt;&lt;/HashRouter&gt; API https://reacttraining.com/react-router/web/api/BrowserRouter &lt;Router>history: objectchildren: node&lt;BrowserRouter>basename: string所有位置的基准 URL。 如果你的应用程序部署在服务器的子目录，则需要将其设置为子目录。 basename 的正确格式是前面有一个前导斜杠，但不能有尾部斜杠。 getUserConfirmation: funcforceRefresh: bool强制刷新页面 keyLength: numberchildren: node&lt;HashRouter>basename: stringgetUserConfirmation: funchashtype: string slash: #/ noslash: # hashbang: #!children: node &lt;StaticRouter>basename: stringlocation: stringlocation: objectcontext: objectchildren: node&lt;MemoruRouter>initialEntries: arrayinitialIndex: numbergetUserConfirmation: funckeylength: numberchildren: node&lt;Link>to: stringto: object pathname: url search: query hash: # state: {} replace: funcinnerRef: funcothers &lt;NavLink>activeClassName: stringactiveStyle: objectexact: boolstrict: boolisActive: funclocation: object&lt;Prompt>用于在位置跳转之前给予用户一些确认信息。当你的应用程序进入一个应该阻止用户导航的状态时（比如表单只填写了一半），弹出一个提示。 message: stringmessage: funcwhen: bool&lt;Redirect>to: stringto: objectpush: boolfrom: stringexact: boolstrict: bool&lt;Switch>location: objectchildren: nodewithRouter将非路由组件变成路由组件12import &#123;withRouter&#125; from 'react-router-dom'export default withRouter(`组件名`) 编程式导航history在props上有history对象，这个对象上存在多个个方法 push replace","categories":[{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/categories/React/"}],"tags":[{"name":"Route","slug":"Route","permalink":"http://blog.bevexed.top/tags/Route/"}]},{"title":"vue查漏补缺","slug":"vue查漏补缺","date":"2019-02-11T08:59:36.000Z","updated":"2019-06-12T04:00:07.527Z","comments":true,"path":"2019/02/11/vue查漏补缺/","link":"","permalink":"http://blog.bevexed.top/2019/02/11/vue查漏补缺/","excerpt":"","text":"Vue 不支持 IE8 及以下版本CDN1&lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.22/dist/vue.js\"&gt;&lt;/script&gt; key确保相同的元素被切换时会重新渲染 v-for 可以对对象的属性进行迭代 提供了 value、 key、 index 三个参数 12345&lt;ul id=\"v-for-object\" class=\"demo\"&gt; &lt;li v-for=\"(value, key, index) in object\"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125;: &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt; 12345678910new Vue(&#123; el: '#v-for-object', data: &#123; object: &#123; firstName: 'John', lastName: 'Doe', age: 30 &#125; &#125;&#125;) 数组的更新检测 push() pop() shift() unshift() splice() sort() reverse() 注意事项由于 JavaScript 的限制，Vue 不能检测以下变动的数组： 当你利用索引直接设置一个项时，例如： 1234567vm.items[indexOfItem] = newValue// 通过一下方法替代// Vue.setVue.set(vm.items, indexOfItem, newValue)// Array.prototype.splicevm.items.splice(indexOfItem, 1, newValue) 当你修改数组的长度时，例如： 1vm.items.length = newLength 修饰符事件处理 .stop .prevent .capture .self .once .passive 按键 .enter .tab .delete (捕获“删除”和“退格”键) .esc .space .up .down .left .right 系统 .ctrl .alt .shift .meta 鼠标 .left .right .middle 表单 .lazy .trim .number slot具名slot 模板123&lt;header&gt; &lt;slot name=\"header\"&gt;&lt;/slot&gt;&lt;/header&gt; 使用1234// template 可以是任意元素 &lt;template slot=\"header\"&gt; &lt;h1&gt;Here might be a page title&lt;/h1&gt;&lt;/template&gt; 动画过渡类名 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to: 2.1.8版及以上 定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave: 定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to: 2.1.8版及以上 定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://blog.bevexed.top/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://blog.bevexed.top/tags/Vue/"},{"name":"修饰符","slug":"修饰符","permalink":"http://blog.bevexed.top/tags/修饰符/"}]},{"title":"Vue微信支付授权的坑（当前页面的URL未注册）","slug":"vue微信支付授权（一）","date":"2019-02-11T05:45:11.000Z","updated":"2019-02-13T06:05:17.564Z","comments":true,"path":"2019/02/11/vue微信支付授权（一）/","link":"","permalink":"http://blog.bevexed.top/2019/02/11/vue微信支付授权（一）/","excerpt":"","text":"获取微信授权的URL微信支付之前都要获取微信授权，由于微信对 IOS 和 Android 的 URL 的处理不同，所以这里统一使用这个方法获取授权时使用的 URL1let url = window.location.href.split('#')[0]; ? 的作用尽管你向后台发送了被#截取过的授权URL，但是在真正支付的时候，你或许还是会看到 URL未注册的情况。 解决问题 这个时候请大胆的在当前的页面的#前面拼接? 微信在检验URL的时候，如果URL字符串内有?,会将?前的所有内容全部截取 如果?出现在#后，会导致#前的内容也被截取，从而导致认证失败 所以这里通过提前加?的方式避开了认证地址截取过多的问题","categories":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://blog.bevexed.top/categories/微信公众号/"}],"tags":[{"name":"微信","slug":"微信","permalink":"http://blog.bevexed.top/tags/微信/"},{"name":"Vue","slug":"Vue","permalink":"http://blog.bevexed.top/tags/Vue/"},{"name":"授权","slug":"授权","permalink":"http://blog.bevexed.top/tags/授权/"}]},{"title":"使用vue-property-decorator","slug":"使用vue-property-decorator","date":"2019-02-01T02:41:10.000Z","updated":"2019-06-12T04:00:22.055Z","comments":true,"path":"2019/02/01/使用vue-property-decorator/","link":"","permalink":"http://blog.bevexed.top/2019/02/01/使用vue-property-decorator/","excerpt":"","text":"@Emit@Emit(event?: string) decorator123456789101112131415161718192021222324252627282930import &#123; Vue, Component, Emit &#125; from 'vue-property-decorator'@Componentexport default class YourComponent extends Vue &#123; count = 0 @Emit() addToCount(n: number) &#123; this.count += n &#125; @Emit('reset') resetCount() &#123; this.count = 0 &#125; @Emit() returnValue() &#123; return 10 &#125; @Emit() promise() &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(20) &#125;, 0) &#125;) &#125;&#125; 等价于12345678910111213141516171819202122232425262728293031export default &#123; data() &#123; return &#123; count: 0 &#125; &#125;, methods: &#123; addToCount(n) &#123; this.count += n this.$emit('add-to-count', n) &#125;, resetCount() &#123; this.count = 0 this.$emit('reset') &#125;, returnValue() &#123; this.$emit('return-value', 10) &#125;, promise() &#123; const promise = new Promise(resolve =&gt; &#123; setTimeout(() =&gt; &#123; resolve(20) &#125;, 0) &#125;) promise.then(value =&gt; &#123; this.$emit('promise', value) &#125;) &#125; &#125;&#125; @Inject@Model@Model(event?: string, options: (PropOptions | Constructor[] | Constructor) = {}) decorator123456import &#123; Vue, Component, Model &#125; from 'vue-property-decorator'@Componentexport default class YourComponent extends Vue &#123; @Model('change', &#123; type: Boolean &#125;) checked!: boolean&#125; 等价于1234567891011export default &#123; model: &#123; prop: 'checked', event: 'change' &#125;, props: &#123; checked: &#123; type: Boolean &#125;, &#125;,&#125; @Prop@Prop(options: (PropOptions | Constructor[] | Constructor) = {}) decorator12345678import &#123; Vue, Component, Prop &#125; from 'vue-property-decorator'@Componentexport default class YourComponent extends Vue &#123; @Prop(Number) propA!: number @Prop(&#123; default: 'default value' &#125;) propB!: string @Prop([String, Boolean]) propC!: string | boolean&#125; 等价于12345678910111213export default &#123; props: &#123; propA: &#123; type: Number &#125;, propB: &#123; default: 'default value' &#125;, propC: &#123; type: [String, Boolean] &#125;, &#125;&#125; @Provide@Provide(key?: string | symbol) / @Inject(options?: { from?: InjectKey, default?: any } | InjectKey) decorator123456789101112131415import &#123; Component, Inject, Provide, Vue &#125; from 'vue-property-decorator'const symbol = Symbol('baz')@Componentexport class MyComponent extends Vue &#123; @Inject() foo!: string @Inject('bar') bar!: string @Inject(&#123; from: 'optional', default: 'default' &#125;) optional!: string @Inject(symbol) baz!: string @Provide() foo = 'foo' @Provide('bar') baz = 'bar'&#125; 等价于1234567891011121314151617181920212223const symbol = Symbol('baz')export const MyComponent = Vue.extend(&#123; inject: &#123; foo: 'foo', bar: 'bar', 'optional': &#123; from: 'optional', default: 'default' &#125;, [symbol]: symbol &#125;, data () &#123; return &#123; foo: 'foo', baz: 'bar' &#125; &#125;, provide () &#123; return &#123; foo: this.foo, bar: this.baz &#125; &#125;&#125;) @Watch@Watch(path: string, options: WatchOptions = {}) decorator12345678910111213import &#123; Vue, Component, Watch &#125; from 'vue-property-decorator'@Componentexport default class YourComponent extends Vue &#123; @Watch('child') onChildChanged(val: string, oldVal: string) &#123; &#125; @Watch('person', &#123; immediate: true, deep: true &#125;) onPersonChanged1(val: Person, oldVal: Person) &#123; &#125; @Watch('person') onChildChanged2(val: Person, oldVal: Person) &#123; &#125;&#125; 等价于12345678910111213141516171819202122232425262728export default &#123; watch: &#123; 'child': [ &#123; handler: 'onChildChanged', immediate: false, deep: false &#125; ], 'person': [ &#123; handler: 'onPersonChanged1', immediate: true, deep: true &#125;, &#123; handler: 'onPersonChanged2', immediate: false, deep: false &#125; ] &#125;, methods: &#123; onChildChanged(val, oldVal) &#123; &#125;, onPersonChanged1(val, oldVal) &#123; &#125; onPersonChanged2(val, oldVal) &#123; &#125; &#125;&#125; 注意事项 父组件的函数的参数问题 @Component (provided by vue-class-component)@Component({ components: { HelloWorld, },}) Mixins (the helper function named mixins provided by vue-class-component)参考https://github.com/kaorun343/vue-property-decorator","categories":[{"name":"Vue","slug":"Vue","permalink":"http://blog.bevexed.top/categories/Vue/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.bevexed.top/tags/TypeScript/"}]},{"title":"Vue-cli搭建基于typeScript的Vue项目","slug":"Vue-cli搭建基于typeScript的Vue项目","date":"2019-02-01T02:09:14.000Z","updated":"2019-06-12T03:59:40.569Z","comments":true,"path":"2019/02/01/Vue-cli搭建基于typeScript的Vue项目/","link":"","permalink":"http://blog.bevexed.top/2019/02/01/Vue-cli搭建基于typeScript的Vue项目/","excerpt":"","text":"安装 Vue-cli1&gt; npm install -g @vue/cli 生成项目选一个文件夹1&gt; vue create &lt;项目名称&gt; 配置项目选择 Manually select features123? Please pick a preset: default (babel, eslint) ❯ Manually select features // 选这个 配置具体选项这里根据具体情况选择,因为要使用 TypeScript,所以务必选上1234567891011? Please pick a preset: Manually select features? Check the features needed for your project: ◉ Babel ◉ TypeScript ◯ Progressive Web App (PWA) Support ◯ Router ◯ Vuex❯◯ CSS Pre-processors ◉ Linter / Formatter ◯ Unit Testing ◯ E2E Testing 参考文章教你搭建基于typescript的vue项目","categories":[{"name":"Vue","slug":"Vue","permalink":"http://blog.bevexed.top/categories/Vue/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.bevexed.top/tags/TypeScript/"}]},{"title":"React基本操作","slug":"React基本操作","date":"2019-01-30T07:57:47.000Z","updated":"2019-02-13T02:21:17.697Z","comments":true,"path":"2019/01/30/React基本操作/","link":"","permalink":"http://blog.bevexed.top/2019/01/30/React基本操作/","excerpt":"","text":"安装1&gt; npm install -g create-react-app 创建1&gt; create-react-app 安装插件12&gt; yarn init&gt; yarn add react react-dom 补充修改端口1&#123;\"start\": \"PORT=9000 react-scripts start\"&#125;","categories":[{"name":"React","slug":"React","permalink":"http://blog.bevexed.top/categories/React/"}],"tags":[]},{"title":"ubuntu 18.04 安装配置Nginx","slug":"安装配置Nginx（ubuntu）","date":"2019-01-29T03:44:14.000Z","updated":"2019-09-06T05:51:05.412Z","comments":true,"path":"2019/01/29/安装配置Nginx（ubuntu）/","link":"","permalink":"http://blog.bevexed.top/2019/01/29/安装配置Nginx（ubuntu）/","excerpt":"","text":"安装1&gt; apt install nginx 配置防火墙1&gt; sudo ufw app list 输入命令后，你会看到12345Available applications: Nginx Full 这个配置打开 80端口和443端口 Nginx HTTP 这个配置只打开80 (普通, 未加密通信) Nginx HTTPS 这个配置只打开 443 (TLS/SSL 加密通信) OpenSSH 打开服务1&gt; sudo ufw allow 'Nginx Full' 查看服务是否打开验证服务状态1&gt; sudo ufw status 检查 web server1&gt; systemctl status nginx 通过 IP 访问输入你的网站IP即可 管理 Nginx进程停止1&gt; sudo systemctl stop nginx 启动1&gt; sudo systemctl start nginx 重启1&gt; sduo systemctl restart nginx 开机启动1&gt; sudo systemctl enable nginx 禁止开机启动1&gt; sudo systemctl disable nginx 配置网站文件位置 /var/www/html 修改网站根目录 进入Nginx配置文件 1&gt; sudo vim /etc/nginx/sites-available/default 将 root 所对应网站根目录进行修改 成你的目录 重启nginx1&gt; sudo systemctl restart nginx 服务器配置配置文件目录 /etc/nginx: nginx主配置文件 /etc/nginx/nginx.conf 参考文章http://www.nginx.cn/4723.html","categories":[{"name":"服务器","slug":"服务器","permalink":"http://blog.bevexed.top/categories/服务器/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"http://blog.bevexed.top/tags/Nginx/"}]},{"title":"documentElement 与 body","slug":"documentElement与body","date":"2019-01-23T08:08:53.000Z","updated":"2019-06-12T05:26:34.567Z","comments":true,"path":"2019/01/23/documentElement与body/","link":"","permalink":"http://blog.bevexed.top/2019/01/23/documentElement与body/","excerpt":"","text":"documentElement 与 bodydocument.documentElement 返回 htmldom 中的 root 节点 document.body 返回 htmldom 中的 body 节点 差异scrollTop iso 上两者都可以获取 scrollTop，但是只有body可以设置该值兼容解决方案 对两则同时赋值 123let top = 100document.documentElement.scrollTop = topdocument.body.scrollTop = top","categories":[{"name":"DOM","slug":"DOM","permalink":"http://blog.bevexed.top/categories/DOM/"}],"tags":[{"name":"Scroll","slug":"Scroll","permalink":"http://blog.bevexed.top/tags/Scroll/"}]},{"title":"微信公众号授权","slug":"微信公众号授权","date":"2019-01-22T05:47:34.000Z","updated":"2019-02-13T02:20:48.300Z","comments":true,"path":"2019/01/22/微信公众号授权/","link":"","permalink":"http://blog.bevexed.top/2019/01/22/微信公众号授权/","excerpt":"","text":"微信网页授权资源微信公众平台开发者文档： https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421140842 具体操作网页授权回调域名 在 “开发 - 接口权限 - 网页服务 - 网页帐号 - 网页授权获取用户基本信息” 的配置选项中，修改授权回调域名 这里填写的是域名（是一个字符串），而不是URL，因此请勿加 http:// 等协议头； 授权回调域名不允许跨域 前端部分用户同意授权，获取code 前端只要处理这一步就可以了 接口 https://open.weixin.qq.com/connect/oauth2/authorize?appid=APPID&amp;redirect_uri=REDIRECT_URI&amp;response_type=code&amp;scope=SCOPE&amp;state=STATE#wechat_redirect 参数 参数 是否必须 说明 appid 是 公众号唯一标识 redirect_uri 是 授权后重定向的回调链接地址， 请使用 urlEncode 对链接进行处理 response_type 是 返回类型，请填写code scope 是 应用授权作用域，snsapi_base （不弹出授权页面，直接跳转，只能获取用户openid），snsapi_userinfo （弹出授权页面，可通过openid拿到昵称、性别、所在地。并且， 即使在未关注的情况下，只要用户授权，也能获取其信息 ） state 否 重定向后会带上state参数，开发者可以填写a-zA-Z0-9的参数值，最多128字节 #wechat_redirect are neat 无论直接打开还是做页面302重定向时候，必须带此参数 回调 授权成功后，微信会在新的回调页面的url上拼接code 通过query再url中拿到code,传递给后端即可 后端部分通过code换取网页授权access_token刷新access_token（如果需要）拉取用户信息(需scope为 snsapi_userinfo)检验授权凭证（access_token）是否有效","categories":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://blog.bevexed.top/categories/微信公众号/"}],"tags":[{"name":"微信","slug":"微信","permalink":"http://blog.bevexed.top/tags/微信/"},{"name":"授权","slug":"授权","permalink":"http://blog.bevexed.top/tags/授权/"}]},{"title":"gulp 学习","slug":"gulp","date":"2019-01-21T09:32:53.000Z","updated":"2019-04-12T10:14:54.094Z","comments":true,"path":"2019/01/21/gulp/","link":"","permalink":"http://blog.bevexed.top/2019/01/21/gulp/","excerpt":"","text":"Gulp 任务化Gulp.js 是一个自动化构建工具，开发者可以使用它在项目开发过程中自动执行常见任务。 基于流Gulp.js 是基于 Node.js 构建的，利用 Node.js 流的威力，你可以快速构建项目并减少频繁的 IO 操作。Gulp.js 源文件和你用来定义任务的 Gulp 文件都是通过 JavaScript（或者 CoffeeScript ）源码来实现的。 安装全局安装1&gt; npm install -g gulp 局部安装1&gt; npm install -S gulp 使用 在项目根目录下创建一个名为 gulpfile.js 的文件： 3.012345const gulp = require('gulp');gulp.task('something', function() &#123; // 将你的默认的任务代码放在这&#125;); 4.012345678const gulp = require('gulp');gulp.task('default', gulp.series( // 任务),function() &#123; // 将你的默认的任务代码放在这&#125;); 运行1$ gulp 常用插件 都需要 npm 安装到依赖中 -S gulp-connect 自动打开浏览器 gulp-concat 合并 js/css 文件 gulp-uglify 压缩 js 文件 gulp-babel 将es6转换为es5 gulp-rename 文件重命名 gulp-less 编译 less gulp-clean-css 压缩 css gulp-rev &amp; gulp-rev-collector 为文件加上版本号，并且自动修改html中关于压缩文件的引用路径 gulp-livereload 实时自动编译刷新 gulp-htmlmin 压缩 HTML gulp-load-plugins 万用插件gulp-load-plugins 是依赖 package.json 文件来加载插件的，所以请确保你需要的插件已经加入 package.json 文件并已经安装完毕。 常用 APIgulp.task 注册任务 3.0 gulp.task(name[, deps], fn) name : 任务名不要带空格 deps ： type ：Array 一个包含任务列表的数组，这些任务会在你当前任务运行之前完成。 fn : 回调函数4.0 gulp.task(parallel and series, fn) gulp4不再能够通过数组形式传入任务，你需要使用gulp.series()和gulp.parallel()来执行他们 parallel 异步任务 series 同步任务12gulp.task('default',gulp.parallel('taskA','taskB'));//并行执行gulp.task('default',gulp.series('taskA','taskB'));//按顺序执行 gulp.watch 监视任务 实例 所需组件请自行引入 合并 压缩 JS 任务1234567891011const concat = require('gulp-concat')const uglify = require('gulp-uglify')gulp.task('concatJs',function() &#123; // 有 return 是异步，无 return 是同步 return gulp.src('路径') // 将数据读取到内存中 .pipe(concat('临时合并文件名')) // 临时合并文件 .pipe(uglify()) // 压缩文件 .pipe(rename(&#123;suffix:'.min'&#125;)) // 改名 .pipe(gulp.dest('输出文件目录')) // 输出文件&#125;) 合并 压缩 CSS 任务12345678910111213141516const cssClean = require('gulp-clean-css');const less = require('gulp-less');// 编译less为cssgulp.task('less',function() &#123; return gulp.src('路径') // 将数据读取到内存中 .pipe(less()) // 编译less为css&#125;)// 合并并压缩 css文件gulp.task('css',['less'],function() &#123; return gulp.src('路径') // 将数据读取到内存中 .pipe(concat('临时合并文件名')) // 合并文件 .pipe(rename(&#123;suffix:'.min'&#125;)) // 改名 .pipe(cssClean(&#123;compatibility:'ie8'&#125;)) .pipe(gulp.dest('输出文件目录')) // 输出文件&#125;) 压缩 HTML1234567const htmlMin = require('gulp-htmlmin')gulp.task('less',function() &#123; return gulp.src('路径') // 将数据读取到内存中 .pipe(htmlMin(&#123;collaspeWhitespace:true&#125;)) // 压缩 HTML .pipe(gulp.dest('输出文件目录'))&#125;) 注意项return任务注册时有return 任务异步 任务结束后释放内存 任务中无return 任务同步 任务结束后，不会释放内存","categories":[{"name":"构建工具","slug":"构建工具","permalink":"http://blog.bevexed.top/categories/构建工具/"}],"tags":[{"name":"Gulp","slug":"Gulp","permalink":"http://blog.bevexed.top/tags/Gulp/"}]},{"title":"TypeScript","slug":"typeScript","date":"2019-01-21T09:21:43.000Z","updated":"2019-06-11T09:57:07.442Z","comments":true,"path":"2019/01/21/typeScript/","link":"","permalink":"http://blog.bevexed.top/2019/01/21/typeScript/","excerpt":"","text":"TypeScript JavaScript 的超集 微软开发的开源编程语言 遵循最新的 ES6、ES5规范 提供了类型校验 好处 为日后维护带来方便 增加代码可读性 提高安全性 安装1&gt; npm install -g typescript 编译1&gt; tsc &lt;file&gt; 配置生成 tsconfig.json1&gt; tsc --init 使用数据类型 TypeScript 中为了使编写的代码更规范，更利于维护，增加了类型校验 布尔值 boolean1let isDone: boolean = false; 数值 number 和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。 1234let decLiteral: number = 6;let hexLiteral: number = 0xf00d;let binaryLiteral: number = 0b1010;let octalLiteral: number = 0o744; 字符串 string12let name: string = \"bob\";name = \"smith\"; 可以使用模板字符串数组类型 list「类型 + 方括号」来表示数组12// 数组中的所有元素都是同一类型let list: number[] = [1, 2, 3]; 使用数组Array Generic泛型表示12// 使用数组 泛型let list: Array&lt;number&gt; = [1, 2, 3]; 用接口表示数组1234interface NumberArray &#123; [index: number]: number; // 只要 index 的类型是 number ，那么 值得类型 必须是 number&#125;let fibonacci: NumberArray = [1, 1, 2, 3, 5]; 类数组1234// 事实上常见的类数组都有自己的接口定义，如 IArguments, NodeList, HTMLCollection 等function sum() &#123; let args: IArguments = arguments;&#125; any 在数组中的应用1let list: any[] = [&#123;a:'b'&#125;, 25, 'a']; 枚举 enum enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。 用于取值被限定在一定范围内的场景，比如一周只能有七天 最好不要使用手动赋值 定义123enum 枚举名 &#123; 标识符[=整形常数]&#125; 12enum Color &#123;Red, Green, Blue&#125;let c: Color = Color.Green; 编号 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号： 手动赋值后，未手动赋值的枚举项会接着上一个枚举项递增 如果未手动赋值的枚举项与手动赋值的重复了，TypeScript 不会察觉到这一点 当手动赋值的枚举项不是数字时，需要使用类型断言来让tsc无视类型检查 手动赋值的枚举项也可以是小数或负数，此时未手动赋值的项递增步仍为112enum Color &#123;Red = 1, Green, Blue=&lt;any&gt;\"A\"&#125;let c: Color = Color.Green; 也可以全部都采取手动赋值 12enum Color &#123;Red = 1, Green = 2, Blue = 4&#125;let c: Color = Color.Green; 可以由枚举的值得到他的名字 1234enum Color &#123;Red = 1, Green, Blue&#125;let colorName: string = Color[2];console.log(colorName); // 显示'Green'因为上面代码里它的值是2 枚举项枚举项分为常数项（constant member）和计算所得项（computed member） 常数项 不具有初始化函数并且之前的枚举成员是常数。在这种情况下，当前枚举成员的值为上一个枚举成员的值加 1。但第一个枚举元素是个例外。如果它没有初始化方法，那么它的初始值为 0。 枚举成员使用常数枚举表达式初始化。常数枚举表达式是 TypeScript 表达式的子集，它可以在编译阶段求值。当一个表达式满足下面条件之一时，它就是一个常数枚举表达式： 数字字面量 引用之前定义的常数枚举成员（可以是在不同的枚举类型中定义的）如果这个成员是在同一个枚举类型中定义的，可以使用非限定名来引用 带括号的常数枚举表达式 +, -, ~ 一元运算符应用于常数枚举表达式 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^ 二元运算符，常数枚举表达式做为其一个操作对象。若常数枚举表达式求值后为 NaN 或 Infinity，则会在编译阶段报错 计算所得项 如果紧接在计算所得项后面的是未手动赋值的项，那么它就会因为无法获得初始值而报错：1234567891011121314enum Color &#123;Red, Green, Blue = \"blue\".length&#125; // '\"blue\".length 就是一个计算所得项。``` ##### 常数枚举 `const enum`常数枚举是使用 `const enum` 定义的枚举类型- 常数枚举与普通枚举的区别是，它会在编译阶段被删除，并且不能包含计算成员。```typescriptconst enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 编译结果1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 外部枚举 declare enum 外部枚举用来描述已经存在的枚举类型的形状。 declare 定义的类型只会用于编译时的检查，编译结果中会被删除。12345678declare enum Directions &#123; Up, Down, Left, Right&#125;let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 编译结果1var directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]; 任意类型 any 为不清楚类型的变量指定一个类型123let notSure: any = 4;notSure = \"maybe a string instead\";notSure = false; // okay, definitely a boolean 空值 void 表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： 12345678// 方法没有返回值function warnUser(): void &#123; console.log(\"This is my warning message\");&#125;// 方法有返回值function Num(): number &#123; return 123&#125; 联合类型 Union Types 表示取值可为多种类型中的一种 当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，只能访问此联合类型的所有类型里共有的属性或方法 联合类型的变量在被赋值的时候，会根据类型推论的规则推断出一个类型123let myFavoriteNumber: string | number;myFavoriteNumber = 'seven';myFavoriteNumber = 7; Null 和 Undefined 默认情况下 null 和 undefined 是所有类型的子类型。 指定了–strictNullChecks标记，null和undefined只能赋值给void和它们各自。1let num:number | null | undefined; 元组 Tuple 元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。 元祖合并了不同类型的对象 数组合并了相同类型的对象 123456// Declare a tuple typelet x: [string, number];// Initialize itx = ['hello', 10]; // OK// Initialize it incorrectlyx = [10, 'hello']; // Error 访问 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 当访问一个越界的元素，会使用联合类型替代： 123x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toStringx[6] = true; // Error, 布尔不是(string | number)类型 Never never类型表示的是那些永不存在的值的类型 声明never的变量只能赋予never类型的值 Object object表示非原始类型 除number，string，boolean，symbol，null或undefined之外的类型 类型推论 TypeScirpt 在没有明确的指定类型的时候会推测出一个类型 如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查12let myFavoriteNumber = 'seven';myFavoriteNumber = 7; // // index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 类型断言 手动指定一个值得类型 类型断言有两种形式1234567// 尖括号 语法let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length;// as 语法 =&gt; jsx 中 必须用这个let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 函数 函数是 JavaScript 中一等功民 声明 一个函数有输入和输出，要在 TypeScript 中对其进行约束，需要把输入和输出都考虑在内 在 TypeScript 的类型定义中，=&gt; 用来表示函数的定义，左边是输入类型，需要用括号括起来，右边是输出类型。具名函数123function f():number &#123; return 123&#125; 匿名函数1234567let f = function():number &#123; return 123&#125;// 这段代码只对登号右侧的匿名函数进行了类型定义，等号左边的 f 是通过赋值操作进行类型推论而推断出来的，如果要对 f 添加类型，则：let f :(x:number,y:number) =&gt; number = function(x:number,y:number):number &#123; return x+y&#125; 用 接口 定义函数12345678interface F &#123; (x:number,y:number):number;&#125;let f:F;f=function(x:number,y:number):number &#123; return x+y&#125; 参数 函数调用时，输入多余或少于要求的参数，是不被允许的定义参数类型123function f(x:number,y:number):number &#123; return 123&#125; 可选参数? 可选参数必须写在最后123function f(x:number,y?:number):number &#123; return 123&#125; 默认参数123function f(x:number=20,y?:number):number &#123; return 123&#125; 剩余参数123function f(a:number,...rest:number[]):number &#123; return 213&#125; 函数重载 重载允许一个函数接收不同数量或类型的参数时，做出不同的处理123456789function f(name:string):stringfunction f(age:number):numberfunction f(str:any) &#123; if (typeof str === 'string')&#123; return `str$&#123;str&#125;` &#125; else &#123; return `str$&#123;str&#125;` &#125;&#125; 类 传统方法中，JavaScript 通过构造函数实现类的概念，通过原型链实现继承 ES6中 class 实现类的概念 类（Class）：定义一个事物的抽象特点，包涵他的属性和方法 对象（Object）：类的实例。通过new实现 面向对象（OOP）的三大特性：封装、继承、多态 封装（Encapsulation）：将数据的操作细节隐藏起来，只暴露对外的接口。外界调用端不需要（也不可能）知道细节，就能通过对外提供的接口来访问该对象，同时也保证了外界无法任意更改对象内部的数据 继承（Inheritance）：子类继承父类，子类除了拥有父类的所有特性外，还有一些更具体的特性 多态（Polymorphism）：由继承而产生了相关的不同的类，对同一个方法可以有不同的响应。比如：Cat和Dog都继承自Animal，但是分别实现了自己的eat方法。此时针对某一实例，我们无需了解它是Cat还是Dog，就可以直接调用eat方法，程序会自动判断出应如何执行eat 存取器（getter&amp;setter）：用以改变属性的读取和赋值行为 修饰符（Modified）：修饰符是一些关键字，用于限定成员或类型的性质，比如public表示公有属性或方法 抽象类（Abstract Class）：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中实现 接口（Interfaces）：不同类之间公有的属性或方法，可以抽象成一个接口。接口可以被类实现（implements）。一个类只能继承自另一个类，但是可以实现多个接口 定义类 class：定义类 constructor：定义构造函数123456789class Person &#123; name:string; // 属性 省略了 public 关键词 constructor(name:string)&#123; // 构造函数 实例化类时触发的方法 this.name = name &#125; run():void&#123; console.log(this.name); &#125; &#125; 继承 extend：实现继承 super：调用父类的构造函数和方法12345class Web extends Person&#123; constructor(name:string)&#123; super(name) &#125;&#125; 存取器使用 getter 和 setter 可以改变属性的赋值和读取行为：1234567891011class Animal &#123; constructor(name:string)&#123; this.name=name; &#125; get name()&#123; return 'a' &#125; set name(value)&#123; console.log('setter'+value); &#125;&#125; 修饰符属性不加修饰符默认是公有属性 公有修饰符 public public 修饰的属性或方法都是公有的，可以在任何地方被访问到 保护类型 protected protected 修饰的属性或方法是受保护的，它和private类似，区别是他在子类中也是被允许访问的 在当前类里、子类里可以访问 私有类型 private private修饰的属性或方法是私有的，不能在声明他的类的外部访问 只有在当前类里可以访问 只读属性 readonly静态类型 static 静态方法：使用static修饰的方法称为静态方法，他们不需要实例化，而是直接通过类来调用 静态属性：使用static修饰的属性称为静态属性，他们不需要实例化，而是直接通过类来调用12345678910111213class Animal &#123; constructor(name:string)&#123; this.name=name &#125; static isAnimal(a)&#123; return a instanceof Animal; &#125;&#125;let a = new Animal('a');Animal.isAnimal(a); //truea.(aisAnimal); // TypeError: a.isAnimal is not a function 多态父类定义一个方法不去实现，让继承他的子类去实现，每一个类有不同的表现1234567891011121314151617class Animal &#123; name:string; constructor(name:string)&#123; this.name=name &#125; eat():void&#123; console.log(this.name); &#125; &#125;class Dog extends Animal &#123; constructor(name:string)&#123; super(name) &#125; eat(name:string):void&#123; console.log(`$&#123;name&#125;吃`); &#125;&#125; 抽象类提供其他类继承的基类，不能直接被实例化 定义abstract定义抽象类和抽象方法 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现 12345678910111213141516171819202122abstract class Animal &#123; public name; public constructor(name) &#123; this.name = name; &#125; public abstract sayHi();&#125;let a = new Animal('Jack'); // index.ts(9,11): error TS2511: Cannot create an instance of the abstract class 'Animal'.class Cat extends Animal &#123; sayHi()&#123; console.log(`$&#123;this.name&#125; say hi.`); &#125; public eat() &#123; console.log(`$&#123;this.name&#125; is eating.`); &#125;&#125;let cat = new Cat('Tom');// index.ts(9,7): error TS2515: Non-abstract class 'Cat' does not implement inherited abstract member 'sayHi' from class 'Animal'. 抽象方法只能放在抽象类里 抽象类的派生类必须必须实现抽象类里的抽象方法123456abstract class Animal &#123; abstract makeSound(): void; move(): void &#123; console.log('roaming the earch...'); &#125;&#125; 接口 InterfacesTypeScript 中，使用 接口 来定义对象的类型 作用 在面向对象的编程中，接口是一种规范的定义，他定义了行为和动作的规范，在程序设计里，接口起到了限制和规范的作用。 接口定义了某一批类所需遵守的规范，接口不关心这些类的内部状态数据，也不关心这些类里方法的实现细节，他只规定这批类里必须提供默写方法，提供这些方法的类就可以满足实际需求。 分类普通接口定义1234interface FullName &#123; firstName:string, secondName:string,&#125; 使用 赋值的时候，变量的形状和接口的形状必须保持一致不可以多，不可以少123456789interface FullName &#123; firstName:string, secondName:string,&#125;let name:FullName= &#123; firstName:'a', secondName:'bc',&#125; 函数类接口(混合类型) 使用接口定义一个函数需要符合的类型 123456interface Config &#123; (value:string):string;&#125;let setData:Config=function(value:string):string &#123; return ''&#125; 当函数有自己的属性和方法 1234567891011121314151617interface Counter &#123; (start:number):string; interval:number; reset():void;&#125;function getCounter():Counter &#123; let counter = &lt;Counter&gt;function(start:number) &#123;&#125; counter.interval=123; counter.reset=function() &#123;&#125; return counter&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 可索引接口对数值、对象的约束1234interface UserArr&#123; [index:number]:number&#125;let arr:UserArr=[123,13] 1234interface UserObj &#123; [index:string]:string&#125;let user:UserObj=&#123;w:'qw'&#125; 类类型接口 实现implements是面向对象的一个重要概念。 一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候可以把特性提取成接口interfaces，用implements关键字来实现，这个特性大大提高了面向对象的灵活性 举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它： 123456789101112131415161718interface Alarm &#123; alert();&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert() &#123; console.log('SecurityDoor alert'); &#125;&#125;class Car implements Alarm &#123; alert() &#123; console.log('Car alert'); &#125;&#125; 一个类也可以实现多个接口 1234567891011121314151617181920interface Alarm &#123; alert();&#125;interface Light &#123; lightOn(); lightOff();&#125;class Car implements Alarm, Light &#123; alert() &#123; console.log('Car alert'); &#125; lightOn() &#123; console.log('Car light on'); &#125; lightOff() &#123; console.log('Car light off'); &#125;&#125; 上例中，Car 实现了 Alarm 和 Light 接口，既能报警，也能开关车灯。 接口扩展12345678910interface A &#123; a():void;&#125;interface B extends A&#123; b():void;&#125;class C implements B&#123; a():void &#123;&#125; b():void &#123;&#125;&#125; 可选属性 可选属性的含义是 该属性 可以不存在，但是 仍然不允许添加未定义的属性 当不需要完全匹配一个形状时，可以用可选属性1234567891011121314interface Person &#123; name:string, age?:number&#125;let ton:Person = &#123; name:'Tom'&#125;// 添加 未定义属性 报错let jone:Person = &#123; name: 'Tom', age: 25, gender: 'male'&#125; 任意属性 希望一个接口允许有任意的属性 12345678910interface Person &#123; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; name: 'Tom', gender: 'male'&#125;; 一旦定义任意属性，那么确定属性 和可选属性的类型都必须是他的类型的子集 123456789101112131415161718192021interface Person &#123; name: string; age?: number; [propName: string]: string;&#125;let tom: Person = &#123; name: 'Tom', age: 25, gender: 'male'&#125;;// index.ts(3,5): error TS2411: Property 'age' of type 'number' is not assignable to string index type 'string'.// index.ts(7,5): error TS2322: Type '&#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;' is not assignable to type 'Person'.// Index signatures are incompatible.// Type 'string | number' is not assignable to type 'string'.// Type 'number' is not assignable to type 'string'.//上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。//另外，在报错信息中可以看出，此时 &#123; name: 'Tom', age: 25, gender: 'male' &#125; 的类型被推断成了 &#123; [x: string]: string | number; name: string; age: number; gender: string; &#125;，这是联合类型和接口的结合。 只读属性 readonly当希望对象中的一些字段只能在创建的时候被赋值，可以用只读属性1234567891011121314interface Person &#123; readonly id: number; name: string; age?: number; [propName: string]: any;&#125;let tom: Person = &#123; id: 89757, name: 'Tom', gender: 'male'&#125;;tom.id = 9527; // 报错 泛型 Generics 泛型是指在定义函数、接口或类的时候，不预先指定具体类型，而在使用的时候在指定类型的一种特性 软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。 无法创建 泛型枚举 和 泛型命名空间定义123function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; 我们给identity添加了类型变量T。T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。之后我们再次使用了T当做返回值类型。现在我们可以知道参数与返回值类型是相同的。这允许我们跟踪函数里使用的类型的信息 使用 传入所有的参数，包括类型参数1let output = identity&lt;string&gt;('myString'); // type of output will be 'string' 这里我们明确的指定了T是 string类型，并做为一个参数传递给了函数 利用类型推论 – 编译器会根据传入的参数自动地帮助我们确定T的类型1let output = identity('myString'); // type of output will be 'string' 这里并没有明确的使用&lt;&gt; 来明确地传入类型；编译器可以查看myString的值，然后把T设置为他的类型。类型推论帮助我们保持代码精简和可读性。 泛型类型 泛型函数的类型 与 非泛型函数的类型 没什么不同，只是有一个类型参数在最前面，想函数声明一样 12345function identity&lt;T&gt;(arg:T):T &#123; return arg;&#125;let myIdentity:&lt;T&gt;(arg:T)=&gt;T=identity; 也可以使用不同的泛型参数名，只要在数量上和使用方式上能对应上就可以 12345function identity&lt;T&gt;(arg:T) &#123; return arg;&#125;let myIdentity: &lt;U&gt;(arg:U)=&gt;U=identity; 还可以使用带有调用签名的对象字面量来定义泛型函数 12345function identity&lt;T&gt;(arg:T):T &#123; return arg;&#125;let myIdentity:&#123;&lt;T&gt;(arg:T):T&#125;=identity; 把上面例子里的对象字面量拿出来作为一个接口 123456789interface GenericIdentityFn &#123; &lt;T&gt;(arg:T):T;&#125;function identity&lt;T&gt;(arg:T):T &#123; return arg;&#125;let myIdntity:GenericIdentityFn=identity; 我们可以把泛型参数当作整个接口的一个参数。这样我们就能清楚的知道使用的具体是哪个泛型类型 123456789interface GenericIdentityFn&lt;T&gt; &#123; (arg:T):T;&#125;function identity&lt;T&gt;(arg:T):T &#123; return arg;&#125;let myIdentity: GenericIdentityFn&lt;number&gt; = identity; 泛型类12345678910111213141516class Min&lt;T&gt;&#123; public list:T[]=[] add(value:T):void&#123; this.list.push(value) &#125; min():T&#123; let min = this.list[0]; this.list.forEach(item =&gt; &#123; if (min &gt; item)&#123; min = item; &#125; &#125;) return min &#125;&#125;const m = new Min&lt;number&gt;() 泛型接口12345678910interface Config&lt;T&gt; &#123; &lt;T&gt;(value:T):T;&#125;function f&lt;T&gt;(value:T):T &#123; return value&#125;let a = f&lt;number&gt;(1);let b:Config&lt;number&gt; = fb(2) 声明文件 当使用第三方库时，需要引用他的声明文件，才能获得对应的代码补全，接口提示功能 通常会吧 声明语句 放到一个单独的文件 （*.d.ts）中 声明文件 必须以 .d.ts 结尾 声明语句 declare var declare var 没有定义一个变量，只是定义了全局变量的类型12declare var jQuert:(selector:string)=&gt;anyjQuert('#foo') 第三方声明文件搜索地址 书写声明文件在不同场景下，声明文件的内容和使用方式有所区别 全局变量：通过 script 标签引入的第三方库，注入全局变量 npm包：通过 import foo from ‘foo’ 导入，符合 ES6模块规范 UMD库：即可以通过 script 标签引入，也可以通过 ES6 模块规范 模块插件：通过 import 导入后，可以改变另一模块的结构 直接扩展全局变量：通过 script 引入后， 改变一个全局变量的结构。比如 ：为 Array.prototype 新增一个方法 通过导入扩展全局变量：通过 import 导入后，可以改变一个全局变量的结构 内置对象JavaScript 中的很多内置对象,可以直接在 TypeScript 中当做定义好了的类型 ECMAScript 的内置对象1234let b: Boolean = new Boolean(1);let e: Error = new Error('Error occurred');let d: Date = new Date();let r: RegExp = /[a-z]/; DOM 和 BOM 的 内置对象Document、HTMLElement、Event、NodeList 等12345let body: HTMLElement = document.body;let allDiv: NodeList = document.querySelectorAll('div');document.addEventListener('click', function(e: MouseEvent) &#123; // Do something&#125;); TypeScript 核心库的定义文件 TypeScript 核心库的定义文件中定义了所有浏览器环境需要用到的类型，并且是预置在 TypeScript 中的。 当你在使用一些常用的方法的时候，TypeScript 实际上已经帮你做了很多类型判断的工作了 用 TypeScript 写 Node.jsNode.js 不是内置对象的一部分，如果想用 TypeScript 写 Node.js，则需要引入第三方声明文件：1&gt; npm install @types/node --save-dev 类型别名 type 给一个类型取一个新名字 类型别名适用于 联合类型12345678910type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n:NameOrResolver) &#123; if (typeof n === 'string')&#123; return n; &#125; else &#123; return n(); &#125;&#125; 字符串字面量类型 约束取值只能是某几个字符串中的一个1234type EventNames = 'click'| 'scroll'|'mouseOver'function handleEvent(ele:Element,event:EventNames) &#123; // do sth&#125; 声明合并参考文章 TypeScript 入门教程 TypeScript Handbook（中文版）","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"http://blog.bevexed.top/categories/TypeScript/"}],"tags":[]}]}